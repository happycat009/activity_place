import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import { resolveDirective as _resolveDirective, createVNode as _createVNode } from "vue";
import { useInjectTreeSelectContext } from './Context';
import { computed, defineComponent, nextTick, ref, shallowRef, watch } from 'vue';
import { optionListProps } from './props';
import useMemo from '../_util/hooks/useMemo';
import KeyCode from '../_util/KeyCode';
import Tree from '../vc-tree/Tree';
var HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: 'flex',
  overflow: 'hidden',
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
export default defineComponent({
  name: 'OptionList',
  inheritAttrs: false,
  props: optionListProps(),
  slots: ['notFoundContent', 'menuItemSelectedIcon'],
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        expose = _ref.expose;
    var context = useInjectTreeSelectContext();
    var treeRef = ref();
    var memoOptions = useMemo(function () {
      return props.options;
    }, [function () {
      return props.open;
    }, function () {
      return props.options;
    }], function (next) {
      return next[0];
    });
    var valueKeys = computed(function () {
      var _context$value = context.value,
          checkedKeys = _context$value.checkedKeys,
          getEntityByValue = _context$value.getEntityByValue;
      return checkedKeys.map(function (val) {
        var entity = getEntityByValue(val);
        return entity ? entity.key : null;
      });
    });
    var mergedCheckedKeys = computed(function () {
      var _context$value2 = context.value,
          checkable = _context$value2.checkable,
          halfCheckedKeys = _context$value2.halfCheckedKeys;

      if (!checkable) {
        return null;
      }

      return {
        checked: valueKeys.value,
        halfChecked: halfCheckedKeys
      };
    });
    watch(function () {
      return props.open;
    }, function () {
      nextTick(function () {
        var _a;

        if (props.open && !props.multiple && valueKeys.value.length) {
          (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({
            key: valueKeys.value[0]
          });
        }
      });
    }, {
      immediate: true,
      flush: 'post'
    }); // ========================== Search ==========================

    var lowerSearchValue = computed(function () {
      return String(props.searchValue).toLowerCase();
    });

    var filterTreeNode = function filterTreeNode(treeNode) {
      if (!lowerSearchValue.value) {
        return false;
      }

      return String(treeNode[context.value.treeNodeFilterProp]).toLowerCase().includes(lowerSearchValue.value);
    }; // =========================== Keys ===========================


    var expandedKeys = shallowRef(context.value.treeDefaultExpandedKeys);
    var searchExpandedKeys = shallowRef(null);
    watch(function () {
      return props.searchValue;
    }, function () {
      if (props.searchValue) {
        searchExpandedKeys.value = props.flattenOptions.map(function (o) {
          return o.key;
        });
      }
    }, {
      immediate: true
    });
    var mergedExpandedKeys = computed(function () {
      if (context.value.treeExpandedKeys) {
        return _toConsumableArray(context.value.treeExpandedKeys);
      }

      return props.searchValue ? searchExpandedKeys.value : expandedKeys.value;
    });

    var onInternalExpand = function onInternalExpand(keys) {
      var _a, _b;

      expandedKeys.value = keys;
      searchExpandedKeys.value = keys;
      (_b = (_a = context.value).onTreeExpand) === null || _b === void 0 ? void 0 : _b.call(_a, keys);
    }; // ========================== Events ==========================


    var onListMouseDown = function onListMouseDown(event) {
      event.preventDefault();
    };

    var onInternalSelect = function onInternalSelect(_, _ref2) {
      var key = _ref2.node.key;

      var _a, _b;

      var _context$value3 = context.value,
          getEntityByKey = _context$value3.getEntityByKey,
          checkable = _context$value3.checkable,
          checkedKeys = _context$value3.checkedKeys;
      var entity = getEntityByKey(key, checkable ? 'checkbox' : 'select');

      if (entity !== null) {
        (_a = props.onSelect) === null || _a === void 0 ? void 0 : _a.call(props, entity.data.value, {
          selected: !checkedKeys.includes(entity.data.value)
        });
      }

      if (!props.multiple) {
        (_b = props.onToggleOpen) === null || _b === void 0 ? void 0 : _b.call(props, false);
      }
    }; // ========================= Keyboard =========================


    var activeKey = ref(null);
    var activeEntity = computed(function () {
      return context.value.getEntityByKey(activeKey.value);
    });

    var setActiveKey = function setActiveKey(key) {
      activeKey.value = key;
    };

    expose({
      scrollTo: function scrollTo() {
        var _b2;

        var _a, _b;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (_b = (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo) === null || _b === void 0 ? void 0 : (_b2 = _b).call.apply(_b2, [_a].concat(args));
      },
      onKeydown: function onKeydown(event) {
        var _a, _b;

        var which = event.which;

        switch (which) {
          // >>> Arrow keys
          case KeyCode.UP:
          case KeyCode.DOWN:
          case KeyCode.LEFT:
          case KeyCode.RIGHT:
            (_a = treeRef.value) === null || _a === void 0 ? void 0 : _a.onKeydown(event);
            break;
          // >>> Select item

          case KeyCode.ENTER:
            {
              var _ref3 = ((_b = activeEntity.value) === null || _b === void 0 ? void 0 : _b.data.node) || {},
                  selectable = _ref3.selectable,
                  value = _ref3.value;

              if (selectable !== false) {
                onInternalSelect(null, {
                  node: {
                    key: activeKey.value
                  },
                  selected: !context.value.checkedKeys.includes(value)
                });
              }

              break;
            }
          // >>> Close

          case KeyCode.ESC:
            {
              props.onToggleOpen(false);
            }
        }
      },
      onKeyup: function onKeyup() {}
    });
    return function () {
      var _a;

      var prefixCls = props.prefixCls,
          height = props.height,
          itemHeight = props.itemHeight,
          virtual = props.virtual,
          multiple = props.multiple,
          searchValue = props.searchValue,
          open = props.open,
          _props$notFoundConten = props.notFoundContent,
          notFoundContent = _props$notFoundConten === void 0 ? (_a = slots.notFoundContent) === null || _a === void 0 ? void 0 : _a.call(slots) : _props$notFoundConten,
          onMouseenter = props.onMouseenter;
      var _context$value4 = context.value,
          checkable = _context$value4.checkable,
          treeDefaultExpandAll = _context$value4.treeDefaultExpandAll,
          treeIcon = _context$value4.treeIcon,
          showTreeIcon = _context$value4.showTreeIcon,
          switcherIcon = _context$value4.switcherIcon,
          treeLine = _context$value4.treeLine,
          loadData = _context$value4.loadData,
          treeLoadedKeys = _context$value4.treeLoadedKeys,
          treeMotion = _context$value4.treeMotion,
          onTreeLoad = _context$value4.onTreeLoad; // ========================== Render ==========================

      if (memoOptions.value.length === 0) {
        return _createVNode("div", {
          "role": "listbox",
          "class": "".concat(prefixCls, "-empty"),
          "onMousedown": onListMouseDown
        }, [notFoundContent]);
      }

      var treeProps = {};

      if (treeLoadedKeys) {
        treeProps.loadedKeys = treeLoadedKeys;
      }

      if (mergedExpandedKeys.value) {
        treeProps.expandedKeys = mergedExpandedKeys.value;
      }

      return _createVNode("div", {
        "onMousedown": onListMouseDown,
        "onMouseenter": onMouseenter
      }, [activeEntity.value && open && _createVNode("span", {
        "style": HIDDEN_STYLE,
        "aria-live": "assertive"
      }, [activeEntity.value.data.value]), _createVNode(Tree, _objectSpread(_objectSpread({
        "ref": treeRef,
        "focusable": false,
        "prefixCls": "".concat(prefixCls, "-tree"),
        "treeData": memoOptions.value,
        "height": height,
        "itemHeight": itemHeight,
        "virtual": virtual,
        "multiple": multiple,
        "icon": treeIcon,
        "showIcon": showTreeIcon,
        "switcherIcon": switcherIcon,
        "showLine": treeLine,
        "loadData": searchValue ? null : loadData,
        "motion": treeMotion,
        "checkable": checkable,
        "checkStrictly": true,
        "checkedKeys": mergedCheckedKeys.value,
        "selectedKeys": !checkable ? valueKeys.value : [],
        "defaultExpandAll": treeDefaultExpandAll
      }, treeProps), {}, {
        "onActiveChange": setActiveKey,
        "onSelect": onInternalSelect,
        "onCheck": onInternalSelect,
        "onExpand": onInternalExpand,
        "onLoad": onTreeLoad,
        "filterTreeNode": filterTreeNode
      }), _extends(_extends({}, slots), {
        checkable: context.value.customCheckable
      }))]);
    };
  }
});