"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vue = require("vue");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _vueTypes = _interopRequireDefault(require("../_util/vue-types"));

var _propsUtil = require("../_util/props-util");

var _BaseMixin = _interopRequireDefault(require("../_util/BaseMixin"));

var _createChainedFunction = _interopRequireDefault(require("../_util/createChainedFunction"));

var _Notice = _interopRequireDefault(require("./Notice"));

var _transition = require("../_util/transition");

var _configProvider = _interopRequireWildcard(require("../config-provider"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

function noop() {}

var seed = 0;
var now = Date.now();

function getUuid() {
  return "rcNotification_".concat(now, "_").concat(seed++);
}

var Notification = (0, _vue.defineComponent)({
  mixins: [_BaseMixin.default],
  props: {
    prefixCls: _vueTypes.default.string.def('rc-notification'),
    transitionName: _vueTypes.default.string,
    animation: _vueTypes.default.oneOfType([_vueTypes.default.string, _vueTypes.default.object]).def('fade'),
    maxCount: _vueTypes.default.number,
    closeIcon: _vueTypes.default.any
  },
  data: function data() {
    return {
      notices: []
    };
  },
  methods: {
    getTransitionName: function getTransitionName() {
      var props = this.$props;
      var transitionName = props.transitionName;

      if (!transitionName && props.animation) {
        transitionName = "".concat(props.prefixCls, "-").concat(props.animation);
      }

      return transitionName;
    },
    add: function add(notice) {
      var key = notice.key = notice.key || getUuid();
      var maxCount = this.$props.maxCount;
      this.setState(function (previousState) {
        var notices = previousState.notices;
        var noticeIndex = notices.map(function (v) {
          return v.key;
        }).indexOf(key);
        var updatedNotices = notices.concat();

        if (noticeIndex !== -1) {
          updatedNotices.splice(noticeIndex, 1, notice);
        } else {
          if (maxCount && notices.length >= maxCount) {
            // XXX, use key of first item to update new added (let React to move exsiting
            // instead of remove and mount). Same key was used before for both a) external
            // manual control and b) internal react 'key' prop , which is not that good.
            notice.updateKey = updatedNotices[0].updateKey || updatedNotices[0].key;
            updatedNotices.shift();
          }

          updatedNotices.push(notice);
        }

        return {
          notices: updatedNotices
        };
      });
    },
    remove: function remove(key) {
      this.setState(function (previousState) {
        return {
          notices: previousState.notices.filter(function (notice) {
            return notice.key !== key;
          })
        };
      });
    }
  },
  render: function render() {
    var _this = this;

    var prefixCls = this.prefixCls,
        notices = this.notices,
        remove = this.remove,
        getTransitionName = this.getTransitionName,
        $attrs = this.$attrs;
    var transitionProps = (0, _transition.getTransitionGroupProps)(getTransitionName());
    var noticeNodes = notices.map(function (notice, index) {
      var update = Boolean(index === notices.length - 1 && notice.updateKey);
      var key = notice.updateKey ? notice.updateKey : notice.key;
      var content = notice.content,
          duration = notice.duration,
          closable = notice.closable,
          onClose = notice.onClose,
          style = notice.style,
          className = notice.class;
      var close = (0, _createChainedFunction.default)(remove.bind(_this, notice.key), onClose);
      var noticeProps = {
        prefixCls: prefixCls,
        duration: duration,
        closable: closable,
        update: update,
        closeIcon: (0, _propsUtil.getComponent)(_this, 'closeIcon', {
          prefixCls: prefixCls
        }),
        onClose: close,
        onClick: notice.onClick || noop,
        style: style,
        class: className,
        key: key
      };
      return (0, _vue.createVNode)(_Notice.default, noticeProps, {
        default: function _default() {
          return [typeof content === 'function' ? content({
            prefixCls: prefixCls
          }) : content];
        }
      });
    });
    var className = (0, _defineProperty2.default)({}, prefixCls, 1);
    return (0, _vue.createVNode)("div", {
      "class": className,
      "style": $attrs.style || {
        top: '65px',
        left: '50%'
      }
    }, [(0, _vue.createVNode)(_transition.TransitionGroup, (0, _objectSpread2.default)({
      "tag": "span"
    }, transitionProps), {
      default: function _default() {
        return [noticeNodes];
      }
    })]);
  }
});

Notification.newInstance = function newNotificationInstance(properties, callback) {
  var _a = properties || {},
      _a$name = _a.name,
      name = _a$name === void 0 ? 'notification' : _a$name,
      getContainer = _a.getContainer,
      appContext = _a.appContext,
      customizePrefixCls = _a.prefixCls,
      customRootPrefixCls = _a.rootPrefixCls,
      props = __rest(_a, ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls"]);

  var div = document.createElement('div');

  if (getContainer) {
    var root = getContainer();
    root.appendChild(div);
  } else {
    document.body.appendChild(div);
  }

  var Wrapper = (0, _vue.defineComponent)({
    setup: function setup(_props, _ref) {
      var attrs = _ref.attrs;
      var notiRef = (0, _vue.ref)();
      (0, _vue.onMounted)(function () {
        callback({
          notice: function notice(noticeProps) {
            var _a;

            (_a = notiRef.value) === null || _a === void 0 ? void 0 : _a.add(noticeProps);
          },
          removeNotice: function removeNotice(key) {
            var _a;

            (_a = notiRef.value) === null || _a === void 0 ? void 0 : _a.remove(key);
          },
          destroy: function destroy() {
            (0, _vue.render)(null, div);

            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
          }
        });
      });
      return function () {
        var global = _configProvider.globalConfigForApi;
        var prefixCls = global.getPrefixCls(name, customizePrefixCls);
        var rootPrefixCls = global.getRootPrefixCls(customRootPrefixCls, prefixCls);
        return (0, _vue.createVNode)(_configProvider.default, (0, _objectSpread2.default)((0, _objectSpread2.default)({}, global), {}, {
          "notUpdateGlobalConfig": true,
          "prefixCls": rootPrefixCls
        }), {
          default: function _default() {
            return [(0, _vue.createVNode)(Notification, (0, _objectSpread2.default)((0, _objectSpread2.default)({
              "ref": notiRef
            }, attrs), {}, {
              "prefixCls": prefixCls
            }), null)];
          }
        });
      };
    }
  });
  var vm = (0, _vue.createVNode)(Wrapper, props);
  vm.appContext = appContext || vm.appContext;
  (0, _vue.render)(vm, div);
};

var _default2 = Notification;
exports.default = _default2;