import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  hyphenate,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isHTMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-SNANHIAB.js";
import {
  __commonJS,
  __esm,
  __export
} from "./chunk-ENMAWK7U.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly)
        continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some((p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic));
}
function isText(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      first.properties.unshift(prop);
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    let alreadyExists = false;
    if (prop.key.type === 4) {
      const propKeyName = prop.key.content;
      alreadyExists = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
    }
    if (!alreadyExists) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      if (true)
        ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function getCompatValue(key, context) {
  const config = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config && config[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}
function baseParse(content, options = {}) {
  const context = createParserContext(content, options);
  const start = getCursor(context);
  return createRoot(parseChildren(context, 0, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
  const options = extend({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23);
            parseTag(context, 1, parent);
            continue;
          } else {
            emitError(context, 12, 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
            warnDeprecation("COMPILER_NATIVE_TEMPLATE", context, node.loc);
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(context, 21, 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!context.inPre && node.type === 2) {
        if (!/[^\t\r\n\f ]/.test(node.content)) {
          const prev = nodes[i - 1];
          const next = nodes[i + 1];
          if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match.index <= 3) {
      emitError(context, 0);
    }
    if (match[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match.index);
    const s = context.source.slice(0, match.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, 0, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find((p) => p.type === 6 && p.name === "inline-template");
    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
      const loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
    context.inVPre = true;
    extend(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context)) {
    let hasIf = false;
    let hasFor = false;
    for (let i = 0; i < props.length; i++) {
      const p = props[i];
      if (p.type === 7) {
        if (p.name === "if") {
          hasIf = true;
        } else if (p.name === "for") {
          hasFor = true;
        }
      }
      if (hasIf && hasFor) {
        warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context, getSelection(context, start));
        break;
      }
    }
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: void 0
  };
}
function isComponent(tag, props, context) {
  const options = context.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
          return true;
        }
      }
    } else {
      if (p.name === "is") {
        return true;
      } else if (p.name === "bind" && isStaticArgOf(p.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames = new Set();
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match[0];
  if (nameSet.has(name)) {
    emitError(context, 2);
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern = /["'<]/g;
    let m;
    while (m = pattern.exec(name)) {
      emitError(context, 17, m.index);
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
    let isPropShorthand = startsWith(name, ".");
    let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(match2[2]);
      const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(context, 27);
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
      if (modifiers.includes("prop")) {
        checkCompatEnabled("COMPILER_V_BIND_PROP", context, loc);
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4);
    } else {
      content = parseTextData(context, endIndex, 4);
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while (m = unexpectedChars.exec(match[0])) {
      emitError(context, 18, m.index);
    }
    content = parseTextData(context, match[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return void 0;
  }
  const start = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i = 0; i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start)
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || rawText.indexOf("&") === -1) {
    return rawText;
  } else {
    return context.options.decodeEntities(rawText, mode === 4);
  }
}
function getCursor(context) {
  const { column, line, offset } = context;
  return { column, line, offset };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}
function last(xs) {
  return xs[xs.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ""
  }));
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last(ancestors);
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root, context) {
  walk(root, context, isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12 && getConstantType(child.content, context) >= 2) {
      child.codegenNode = context.hoist(child.codegenNode);
      hoistedCount++;
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(child.branches[i2], context, child.branches[i2].children.length === 1);
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (true)
        ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    root,
    helpers: new Map(),
    components: new Set(),
    directives: new Set(),
    hoists: [],
    imports: [],
    constantCache: new Map(),
    temps: 0,
    cached: 0,
    identifiers: Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = [...context.helpers.keys()];
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        makeBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
  const hasHelpers = ast.helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${ast.helpers.map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`);
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
  const VueBinding = runtimeGlobalName;
  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
  if (ast.helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = ${``}`);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText$1(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText$1(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(node);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(node);
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(true);
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare)
        continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id)
        continue;
      onIdent(stmt.id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(createCompilerError(44, node.loc, void 0, message));
  }
}
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(createCompilerError(30, node.loc));
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(createCompilerError(29, branch.userKey.loc));
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: node.tagType === 3 && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`)
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
      true ? '"v-if"' : '""',
      "true"
    ]));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      makeBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(dir.exp, context);
  if (!parseResult) {
    context.onError(createCompilerError(32, dir.loc));
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0
  };
  if (true) {
    validateBrowserExpression(result.source, context);
  }
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
      if (true) {
        validateBrowserExpression(result.key, context, true);
      }
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
        if (true) {
          validateBrowserExpression(result.index, context, true);
        }
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    if (true) {
      validateBrowserExpression(result.value, context, true);
    }
  }
  return result;
}
function createAliasExpression(range, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = new Set();
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(30, vElse.loc));
      }
    } else if (vFor = findDir(slotElement, "for")) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
      if (parseResult) {
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
          parseResult.source,
          createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
        ]));
      } else {
        context.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn) {
  return createObjectExpression([
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ]);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  const isComponent2 = node.tagType === 1;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
    } else {
      const { name, arg, exp, loc } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
          }
          if (isVBind) {
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc);
                }
              }
              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            mergeArgs.push({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        properties.push(...props2);
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
    }
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
          }
          if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
          createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
            propsExpression
          ])
        ]);
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize2(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp)
          slotName = p.exp;
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize2(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(node, context, nonNameProps);
    slotProps = props;
    if (directives.length) {
      context.onError(createCompilerError(36, directives[0].loc));
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ")
            break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation("COMPILER_FILTER", context, node.loc);
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(46));
    } else if (isModuleMode) {
      onError(createCompilerError(47));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(48));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(49));
  }
  const ast = isString(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(ast, extend({}, options, {
    prefixIdentifiers,
    nodeTransforms: [
      ...nodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {})
  }));
  return generate(ast, extend({}, options, {
    prefixIdentifiers
  }));
}
var errorMessages, FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, locStub, isStaticExp, isBuiltInType, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, propsHelperSet, deprecationData, decodeRE, decodeMap, defaultParserOptions, isSpecialTemplateDirective, allowHoistedHelperSet, PURE_ANNOTATION, isFunctionType, isStaticProperty, isStaticPropertyKey, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, forAliasRE, forIteratorRE, stripParensRE, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, cacheStringFunction, camelizeRE, camelize2, transformSlotOutlet, fnExpRE, transformOn, transformBind, injectPrefix, transformText, seen, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen$1, transformMemo, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    errorMessages = {
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `Error parsing JavaScript expression: `,
      [45]: `<KeepAlive> expects exactly one child component.`,
      [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [47]: `ES module mode is not supported in this build of compiler.`,
      [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [49]: `"scopeId" option is only supported in module mode.`,
      [50]: ``
    };
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
    CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
    CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
    CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
    RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
    RESOLVE_DYNAMIC_COMPONENT = Symbol(true ? `resolveDynamicComponent` : ``);
    RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
    RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
    WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
    NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
    NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
    GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
    SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
    };
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
    nonIdentifierRE = /^\d|[^\$\w]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3.vuejs.org/guide/migration/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3.vuejs.org/guide/migration/v-model.html`
      },
      ["COMPILER_V_BIND_PROP"]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3.vuejs.org/guide/migration/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3.vuejs.org/guide/migration/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3.vuejs.org/guide/migration/inline-template-attribute.html`
      },
      ["COMPILER_FILTER"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3.vuejs.org/guide/migration/filters.html`
      }
    };
    decodeRE = /&(gt|lt|amp|apos|quot);/g;
    decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"'
    };
    defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
    };
    isSpecialTemplateDirective = makeMap(`if,else,else-if,for,slot`);
    allowHoistedHelperSet = new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*#__PURE__*/`;
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(node.content, context);
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(exp, context, dir.name === "slot");
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
          }
        };
      });
    });
    transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const memo = findDir(node, "memo");
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node.loc);
        return () => {
          let childBlock;
          const isTemplate = isTemplateNode(node);
          const { children } = forNode;
          if (isTemplate) {
            node.children.some((c) => {
              if (c.type === 1) {
                const key = findProp(c, "key");
                if (key) {
                  context.onError(createCompilerError(33, key.loc));
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ]));
            loop.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
          } else {
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
          }
        };
      });
    });
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.parseResult = parseForExpression(vFor.exp, context);
        if (result) {
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
    directiveImportMap = new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
        if (props.length > 0) {
          const propsBuildResult = buildProps(node, context);
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(createCompilerError(45, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }));
            }
          }
          const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          if (true) {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          } else {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
      };
    };
    true ? Object.freeze({}) : {};
    true ? Object.freeze([]) : [];
    cacheStringFunction = (fn) => {
      const cache = Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    camelizeRE = /-(\w)/g;
    camelize2 = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
      }
    };
    fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context.onError(createCompilerError(34, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = {
                      type: 8,
                      loc: child.loc,
                      children: [child]
                    };
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``));
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
              };
            }
          }
        };
      }
    };
    seen = new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen.has(node) || context.inVOnce) {
          return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(cur.codegenNode, true);
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(createCompilerError(41, dir.loc));
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      context.bindingMetadata[rawExp];
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context.onError(createCompilerError(42, exp.loc));
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        createObjectProperty(propName, dir.exp),
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTER", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen$1 = new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen$1.has(node)) {
          return;
        }
        seen$1.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              makeBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++)
            ]);
          }
        };
      }
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMNodeTransforms: () => DOMNodeTransforms,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getInnerRange: () => getInnerRange,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isBuiltInType: () => isBuiltInType,
  isCoreComponent: () => isCoreComponent,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  makeBlock: () => makeBlock,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(code, loc, true ? DOMErrorMessages : void 0);
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter((c) => c.type !== 3 && !(c.type === 2 && !c.content.trim()));
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function compile(template, options = {}) {
  return baseCompile(template, extend({}, parserOptions, options, {
    nodeTransforms: [
      ignoreSideEffectTags,
      ...DOMNodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
    transformHoist: null
  }));
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, isRawTextContainer, parserOptions, transformStyle, parseInlineCSS, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, warnTransitionChildren, ignoreSideEffectTags, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : ``);
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(true ? `vModelSelect` : ``);
    V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : ``);
    V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : ``);
    V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : ``);
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : ``);
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    isRawTextContainer = makeMap("style,iframe,script,noscript", true);
    parserOptions = {
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (isBuiltInType(tag, `Transition`)) {
          return TRANSITION;
        } else if (isBuiltInType(tag, `TransitionGroup`)) {
          return TRANSITION_GROUP;
        }
      },
      getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      },
      getTextMode({ tag, ns }) {
        if (ns === 0) {
          if (tag === "textarea" || tag === "title") {
            return 1;
          }
          if (isRawTextContainer(tag)) {
            return 2;
          }
        }
        return 0;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
    };
    DOMErrorMessages = {
      [50]: `v-html is missing expression.`,
      [51]: `v-html will override element children.`,
      [52]: `v-text is missing expression.`,
      [53]: `v-text will override element children.`,
      [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [55]: `v-model argument is not supported on plain elements.`,
      [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [58]: `v-show is missing expression.`,
      [59]: `<Transition> expects exactly one child element or component.`,
      [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(50, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(51, loc));
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))
        ]
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(52, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(53, loc));
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(createSimpleExpression(`textContent`, true), exp ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))
        ]
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(createDOMCompilerError(55, dir.arg.loc));
      }
      function checkDuplicatedValue() {
        const value = findProp(node, "value");
        if (value) {
          context.onError(createDOMCompilerError(57, value.loc));
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(createDOMCompilerError(56, dir.loc));
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(createDOMCompilerError(54, dir.loc));
      }
      baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`, true);
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && (!isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(58, loc));
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    warnTransitionChildren = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (node.children.length && hasMultipleChildren(node)) {
              context.onError(createDOMCompilerError(59, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }));
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(createDOMCompilerError(60, node.loc));
        context.removeNode();
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [warnTransitionChildren] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      on: transformOn2,
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), compiler_dom_esm_bundler_exports);
    var runtimeDom = (init_runtime_dom_esm_bundler(), runtime_dom_esm_bundler_exports);
    var shared = (init_shared_esm_bundler(), shared_esm_bundler_exports);
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          n[k] = e[k];
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespace(runtimeDom);
    var compileCache = Object.create(null);
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = template;
      const cached = compileCache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const { code } = compilerDom.compile(template, shared.extend({
        hoistStatic: true,
        onError,
        onWarn: (e) => onError(e, true)
      }, options));
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return compileCache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default")
        exports[k] = runtimeDom[k];
    });
    exports.compile = compileToFunction;
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/slider-verify-v3/lib/SliderVerify.umd.min.js
var require_SliderVerify_umd_min = __commonJS({
  "node_modules/slider-verify-v3/lib/SliderVerify.umd.min.js"(exports, module) {
    (function(A, e) {
      typeof exports === "object" && typeof module === "object" ? module.exports = e(require_vue()) : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports["SliderVerify"] = e(require_vue()) : A["SliderVerify"] = e(A["Vue"]);
    })(typeof self !== "undefined" ? self : exports, function(A) {
      return function(A2) {
        var e = {};
        function t(n) {
          if (e[n])
            return e[n].exports;
          var r = e[n] = { i: n, l: false, exports: {} };
          return A2[n].call(r.exports, r, r.exports, t), r.l = true, r.exports;
        }
        return t.m = A2, t.c = e, t.d = function(A3, e2, n) {
          t.o(A3, e2) || Object.defineProperty(A3, e2, { enumerable: true, get: n });
        }, t.r = function(A3) {
          typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(A3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(A3, "__esModule", { value: true });
        }, t.t = function(A3, e2) {
          if (1 & e2 && (A3 = t(A3)), 8 & e2)
            return A3;
          if (4 & e2 && typeof A3 === "object" && A3 && A3.__esModule)
            return A3;
          var n = Object.create(null);
          if (t.r(n), Object.defineProperty(n, "default", { enumerable: true, value: A3 }), 2 & e2 && typeof A3 != "string")
            for (var r in A3)
              t.d(n, r, function(e3) {
                return A3[e3];
              }.bind(null, r));
          return n;
        }, t.n = function(A3) {
          var e2 = A3 && A3.__esModule ? function() {
            return A3["default"];
          } : function() {
            return A3;
          };
          return t.d(e2, "a", e2), e2;
        }, t.o = function(A3, e2) {
          return Object.prototype.hasOwnProperty.call(A3, e2);
        }, t.p = "", t(t.s = "fb15");
      }({ "0366": function(A2, e, t) {
        var n = t("1c0b");
        A2.exports = function(A3, e2, t2) {
          if (n(A3), e2 === void 0)
            return A3;
          switch (t2) {
            case 0:
              return function() {
                return A3.call(e2);
              };
            case 1:
              return function(t3) {
                return A3.call(e2, t3);
              };
            case 2:
              return function(t3, n2) {
                return A3.call(e2, t3, n2);
              };
            case 3:
              return function(t3, n2, r) {
                return A3.call(e2, t3, n2, r);
              };
          }
          return function() {
            return A3.apply(e2, arguments);
          };
        };
      }, "057f": function(A2, e, t) {
        var n = t("fc6a"), r = t("241c").f, o = {}.toString, c = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], i = function(A3) {
          try {
            return r(A3);
          } catch (e2) {
            return c.slice();
          }
        };
        A2.exports.f = function(A3) {
          return c && o.call(A3) == "[object Window]" ? i(A3) : r(n(A3));
        };
      }, "06cf": function(A2, e, t) {
        var n = t("83ab"), r = t("d1e7"), o = t("5c6c"), c = t("fc6a"), i = t("c04e"), a = t("5135"), g = t("0cfb"), u = Object.getOwnPropertyDescriptor;
        e.f = n ? u : function(A3, e2) {
          if (A3 = c(A3), e2 = i(e2, true), g)
            try {
              return u(A3, e2);
            } catch (t2) {
            }
          if (a(A3, e2))
            return o(!r.f.call(A3, e2), A3[e2]);
        };
      }, "0a72": function(A2, e, t) {
      }, "0cfb": function(A2, e, t) {
        var n = t("83ab"), r = t("d039"), o = t("cc12");
        A2.exports = !n && !r(function() {
          return Object.defineProperty(o("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      }, "159b": function(A2, e, t) {
        var n = t("da84"), r = t("fdbc"), o = t("17c2"), c = t("9112");
        for (var i in r) {
          var a = n[i], g = a && a.prototype;
          if (g && g.forEach !== o)
            try {
              c(g, "forEach", o);
            } catch (u) {
              g.forEach = o;
            }
        }
      }, "17c2": function(A2, e, t) {
        "use strict";
        var n = t("b727").forEach, r = t("a640"), o = r("forEach");
        A2.exports = o ? [].forEach : function(A3) {
          return n(this, A3, arguments.length > 1 ? arguments[1] : void 0);
        };
      }, "1be4": function(A2, e, t) {
        var n = t("d066");
        A2.exports = n("document", "documentElement");
      }, "1c0b": function(A2, e) {
        A2.exports = function(A3) {
          if (typeof A3 != "function")
            throw TypeError(String(A3) + " is not a function");
          return A3;
        };
      }, "1d80": function(A2, e) {
        A2.exports = function(A3) {
          if (A3 == void 0)
            throw TypeError("Can't call method on " + A3);
          return A3;
        };
      }, "1dde": function(A2, e, t) {
        var n = t("d039"), r = t("b622"), o = t("2d00"), c = r("species");
        A2.exports = function(A3) {
          return o >= 51 || !n(function() {
            var e2 = [], t2 = e2.constructor = {};
            return t2[c] = function() {
              return { foo: 1 };
            }, e2[A3](Boolean).foo !== 1;
          });
        };
      }, "22d1": function(A2, e, t) {
        "use strict";
        (function(A3) {
          t.d(e, "a", function() {
            return n;
          });
          var n = typeof window !== "undefined";
          n && window, Date.now();
        }).call(this, t("c8ba"));
      }, "23cb": function(A2, e, t) {
        var n = t("a691"), r = Math.max, o = Math.min;
        A2.exports = function(A3, e2) {
          var t2 = n(A3);
          return t2 < 0 ? r(t2 + e2, 0) : o(t2, e2);
        };
      }, "23e7": function(A2, e, t) {
        var n = t("da84"), r = t("06cf").f, o = t("9112"), c = t("6eeb"), i = t("ce4e"), a = t("e893"), g = t("94ca");
        A2.exports = function(A3, e2) {
          var t2, u, s, l, C, f, B = A3.target, E = A3.global, d = A3.stat;
          if (u = E ? n : d ? n[B] || i(B, {}) : (n[B] || {}).prototype, u)
            for (s in e2) {
              if (C = e2[s], A3.noTargetGet ? (f = r(u, s), l = f && f.value) : l = u[s], t2 = g(E ? s : B + (d ? "." : "#") + s, A3.forced), !t2 && l !== void 0) {
                if (typeof C === typeof l)
                  continue;
                a(C, l);
              }
              (A3.sham || l && l.sham) && o(C, "sham", true), c(u, s, C, A3);
            }
        };
      }, "241c": function(A2, e, t) {
        var n = t("ca84"), r = t("7839"), o = r.concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(A3) {
          return n(A3, o);
        };
      }, "28fa": function(A2, e) {
        A2.exports = "data:image/png;base64,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";
      }, "2d00": function(A2, e, t) {
        var n, r, o = t("da84"), c = t("342f"), i = o.process, a = i && i.versions, g = a && a.v8;
        g ? (n = g.split("."), r = n[0] < 4 ? 1 : n[0] + n[1]) : c && (n = c.match(/Edge\/(\d+)/), (!n || n[1] >= 74) && (n = c.match(/Chrome\/(\d+)/), n && (r = n[1]))), A2.exports = r && +r;
      }, "342f": function(A2, e, t) {
        var n = t("d066");
        A2.exports = n("navigator", "userAgent") || "";
      }, 3743: function(A2, e, t) {
      }, "37e8": function(A2, e, t) {
        var n = t("83ab"), r = t("9bf2"), o = t("825a"), c = t("df75");
        A2.exports = n ? Object.defineProperties : function(A3, e2) {
          o(A3);
          var t2, n2 = c(e2), i = n2.length, a = 0;
          while (i > a)
            r.f(A3, t2 = n2[a++], e2[t2]);
          return A3;
        };
      }, "3bbe": function(A2, e, t) {
        var n = t("861d");
        A2.exports = function(A3) {
          if (!n(A3) && A3 !== null)
            throw TypeError("Can't set " + String(A3) + " as a prototype");
          return A3;
        };
      }, "428f": function(A2, e, t) {
        var n = t("da84");
        A2.exports = n;
      }, "44ad": function(A2, e, t) {
        var n = t("d039"), r = t("c6b6"), o = "".split;
        A2.exports = n(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(A3) {
          return r(A3) == "String" ? o.call(A3, "") : Object(A3);
        } : Object;
      }, "44d2": function(A2, e, t) {
        var n = t("b622"), r = t("7c73"), o = t("9bf2"), c = n("unscopables"), i = Array.prototype;
        i[c] == void 0 && o.f(i, c, { configurable: true, value: r(null) }), A2.exports = function(A3) {
          i[c][A3] = true;
        };
      }, "492e": function(A2, e) {
        A2.exports = "data:image/png;base64,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";
      }, 4930: function(A2, e, t) {
        var n = t("2d00"), r = t("d039");
        A2.exports = !!Object.getOwnPropertySymbols && !r(function() {
          return !String(Symbol()) || !Symbol.sham && n && n < 41;
        });
      }, "4d64": function(A2, e, t) {
        var n = t("fc6a"), r = t("50c4"), o = t("23cb"), c = function(A3) {
          return function(e2, t2, c2) {
            var i, a = n(e2), g = r(a.length), u = o(c2, g);
            if (A3 && t2 != t2) {
              while (g > u)
                if (i = a[u++], i != i)
                  return true;
            } else
              for (; g > u; u++)
                if ((A3 || u in a) && a[u] === t2)
                  return A3 || u || 0;
            return !A3 && -1;
          };
        };
        A2.exports = { includes: c(true), indexOf: c(false) };
      }, "4d75": function(A2, e, t) {
      }, "4de4": function(A2, e, t) {
        "use strict";
        var n = t("23e7"), r = t("b727").filter, o = t("1dde"), c = o("filter");
        n({ target: "Array", proto: true, forced: !c }, { filter: function(A3) {
          return r(this, A3, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, 5078: function(A2, e) {
        A2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADWElEQVRYR8VXSWsUQRT+Xme7eQjEBSPoUYN60JMgBKK4ZCOi+QPquN+7e6YnnemZrj67G+MfiKBk0wgKwYsH9aASPRowoiKIeMtg5knNpJOaTvcsicP0sfrVe19976uqrwh1/qjO9VEVgFgs1tTauvkwEXUBtIWZt8oFENF3gH8Q0cumJno1PDz8p9KFVQRA160DmoYYMwYAtJVJngUwQ0TXXTf1ohyQsgBM07rHjJiSaB7AFDM+EfGCHGemdiLsBtADYKcfS4RR13XOlwJREoBhJN4BtK9AMyaZeUSI9FSphIaR6CEiyVZvIY7fC5HeHzUnEoBhWOxPYqZBz0s9LEen+l/Xk2eIeMwfE8IJrRU6qOvWEyKcKExu6BDC/lhNcT/WMOw9wNJcoU146nnOyWCeNQDUnmtarj2TyXxdT3F/Tjwe357LaXmtEGHEdZ0Lar4iAFLtRHhTQJw75XmZxxsp7s/V9fgAkfZomYmDnue8XRGqWsBfvRSc6zp9xT1NdALoJGoci2qJpJz57yCAWc9LzwZyT0hhBllYYcC27ebFxaVvAFoB7g2qXdcTNhENAZgDGgaDIJb7LUXXwczDnpe2VQBydwA0CeBXS0vDNtu25XmxehKaZrKbmeUWWxDC2RGkXi0QBFHqXzEI6wuAdiLqcd3UdBEAw7AyAEwi3HVd51JY78MKFeKW8iuPYsfPZZrWHWZcBOAK4cQDAJKjAJ9lxhXPc25HiW8tiHxk2eIySNety0S4BdADIVLnigDoujVFhG6A+4VIT5RSfwCEDA3Vxdo2JvoAGmfGtOc58the1UDdARhGnVvgixDATSGca7UQoWFYNwBcDRWhaSaPMfMMgHkhnF012oaf5XVNRMddN/WsSANDQ0ObstncTwDNNT6Iss3NWpvvmoruAsOwxgH01fIoBjAhhNMfcRcku5j5eeHSqN4DRG1d1RsQ0RHVqoVdx/eZkT8kNuIFfDCqJwizaKGGRLViG/EEqheIsmYVWrLqvYHqASQbVVkynz7Vmq3XlEZZsVARhokoxJYvEGEql8MH1ZZrGvYy5215+0ryjdpyhQn/YXK6YFhKfv/3YaKWkq4pm80dZeZDYU8zgF+3tDTO2rb9uwzIld9lX0aVJlpvXN0B/ANyrAY/RFREagAAAABJRU5ErkJggg==";
      }, "50c4": function(A2, e, t) {
        var n = t("a691"), r = Math.min;
        A2.exports = function(A3) {
          return A3 > 0 ? r(n(A3), 9007199254740991) : 0;
        };
      }, 5135: function(A2, e, t) {
        var n = t("7b0b"), r = {}.hasOwnProperty;
        A2.exports = function(A3, e2) {
          return r.call(n(A3), e2);
        };
      }, 5692: function(A2, e, t) {
        var n = t("c430"), r = t("c6cd");
        (A2.exports = function(A3, e2) {
          return r[A3] || (r[A3] = e2 !== void 0 ? e2 : {});
        })("versions", []).push({ version: "3.12.0", mode: n ? "pure" : "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
      }, "56ef": function(A2, e, t) {
        var n = t("d066"), r = t("241c"), o = t("7418"), c = t("825a");
        A2.exports = n("Reflect", "ownKeys") || function(A3) {
          var e2 = r.f(c(A3)), t2 = o.f;
          return t2 ? e2.concat(t2(A3)) : e2;
        };
      }, 5899: function(A2, e) {
        A2.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
      }, "58a8": function(A2, e, t) {
        var n = t("1d80"), r = t("5899"), o = "[" + r + "]", c = RegExp("^" + o + o + "*"), i = RegExp(o + o + "*$"), a = function(A3) {
          return function(e2) {
            var t2 = String(n(e2));
            return 1 & A3 && (t2 = t2.replace(c, "")), 2 & A3 && (t2 = t2.replace(i, "")), t2;
          };
        };
        A2.exports = { start: a(1), end: a(2), trim: a(3) };
      }, "5c6c": function(A2, e) {
        A2.exports = function(A3, e2) {
          return { enumerable: !(1 & A3), configurable: !(2 & A3), writable: !(4 & A3), value: e2 };
        };
      }, "65f0": function(A2, e, t) {
        var n = t("861d"), r = t("e8b5"), o = t("b622"), c = o("species");
        A2.exports = function(A3, e2) {
          var t2;
          return r(A3) && (t2 = A3.constructor, typeof t2 != "function" || t2 !== Array && !r(t2.prototype) ? n(t2) && (t2 = t2[c], t2 === null && (t2 = void 0)) : t2 = void 0), new (t2 === void 0 ? Array : t2)(e2 === 0 ? 0 : e2);
        };
      }, "68ef": function(A2, e, t) {
      }, "69f3": function(A2, e, t) {
        var n, r, o, c = t("7f9a"), i = t("da84"), a = t("861d"), g = t("9112"), u = t("5135"), s = t("c6cd"), l = t("f772"), C = t("d012"), f = "Object already initialized", B = i.WeakMap, E = function(A3) {
          return o(A3) ? r(A3) : n(A3, {});
        }, d = function(A3) {
          return function(e2) {
            var t2;
            if (!a(e2) || (t2 = r(e2)).type !== A3)
              throw TypeError("Incompatible receiver, " + A3 + " required");
            return t2;
          };
        };
        if (c) {
          var w = s.state || (s.state = new B()), I = w.get, p = w.has, Q = w.set;
          n = function(A3, e2) {
            if (p.call(w, A3))
              throw new TypeError(f);
            return e2.facade = A3, Q.call(w, A3, e2), e2;
          }, r = function(A3) {
            return I.call(w, A3) || {};
          }, o = function(A3) {
            return p.call(w, A3);
          };
        } else {
          var v = l("state");
          C[v] = true, n = function(A3, e2) {
            if (u(A3, v))
              throw new TypeError(f);
            return e2.facade = A3, g(A3, v, e2), e2;
          }, r = function(A3) {
            return u(A3, v) ? A3[v] : {};
          }, o = function(A3) {
            return u(A3, v);
          };
        }
        A2.exports = { set: n, get: r, has: o, enforce: E, getterFor: d };
      }, "6eeb": function(A2, e, t) {
        var n = t("da84"), r = t("9112"), o = t("5135"), c = t("ce4e"), i = t("8925"), a = t("69f3"), g = a.get, u = a.enforce, s = String(String).split("String");
        (A2.exports = function(A3, e2, t2, i2) {
          var a2, g2 = !!i2 && !!i2.unsafe, l = !!i2 && !!i2.enumerable, C = !!i2 && !!i2.noTargetGet;
          typeof t2 == "function" && (typeof e2 != "string" || o(t2, "name") || r(t2, "name", e2), a2 = u(t2), a2.source || (a2.source = s.join(typeof e2 == "string" ? e2 : ""))), A3 !== n ? (g2 ? !C && A3[e2] && (l = true) : delete A3[e2], l ? A3[e2] = t2 : r(A3, e2, t2)) : l ? A3[e2] = t2 : c(e2, t2);
        })(Function.prototype, "toString", function() {
          return typeof this == "function" && g(this).source || i(this);
        });
      }, 7156: function(A2, e, t) {
        var n = t("861d"), r = t("d2bb");
        A2.exports = function(A3, e2, t2) {
          var o, c;
          return r && typeof (o = e2.constructor) == "function" && o !== t2 && n(c = o.prototype) && c !== t2.prototype && r(A3, c), A3;
        };
      }, 7418: function(A2, e) {
        e.f = Object.getOwnPropertySymbols;
      }, "746f": function(A2, e, t) {
        var n = t("428f"), r = t("5135"), o = t("e538"), c = t("9bf2").f;
        A2.exports = function(A3) {
          var e2 = n.Symbol || (n.Symbol = {});
          r(e2, A3) || c(e2, A3, { value: o.f(A3) });
        };
      }, 7839: function(A2, e) {
        A2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      }, "7b0b": function(A2, e, t) {
        var n = t("1d80");
        A2.exports = function(A3) {
          return Object(n(A3));
        };
      }, "7c73": function(A2, e, t) {
        var n, r = t("825a"), o = t("37e8"), c = t("7839"), i = t("d012"), a = t("1be4"), g = t("cc12"), u = t("f772"), s = ">", l = "<", C = "prototype", f = "script", B = u("IE_PROTO"), E = function() {
        }, d = function(A3) {
          return l + f + s + A3 + l + "/" + f + s;
        }, w = function(A3) {
          A3.write(d("")), A3.close();
          var e2 = A3.parentWindow.Object;
          return A3 = null, e2;
        }, I = function() {
          var A3, e2 = g("iframe"), t2 = "java" + f + ":";
          return e2.style.display = "none", a.appendChild(e2), e2.src = String(t2), A3 = e2.contentWindow.document, A3.open(), A3.write(d("document.F=Object")), A3.close(), A3.F;
        }, p = function() {
          try {
            n = document.domain && new ActiveXObject("htmlfile");
          } catch (e2) {
          }
          p = n ? w(n) : I();
          var A3 = c.length;
          while (A3--)
            delete p[C][c[A3]];
          return p();
        };
        i[B] = true, A2.exports = Object.create || function(A3, e2) {
          var t2;
          return A3 !== null ? (E[C] = r(A3), t2 = new E(), E[C] = null, t2[B] = A3) : t2 = p(), e2 === void 0 ? t2 : o(t2, e2);
        };
      }, "7f9a": function(A2, e, t) {
        var n = t("da84"), r = t("8925"), o = n.WeakMap;
        A2.exports = typeof o === "function" && /native code/.test(r(o));
      }, "81d5": function(A2, e, t) {
        "use strict";
        var n = t("7b0b"), r = t("23cb"), o = t("50c4");
        A2.exports = function(A3) {
          var e2 = n(this), t2 = o(e2.length), c = arguments.length, i = r(c > 1 ? arguments[1] : void 0, t2), a = c > 2 ? arguments[2] : void 0, g = a === void 0 ? t2 : r(a, t2);
          while (g > i)
            e2[i++] = A3;
          return e2;
        };
      }, "81da": function(A2, e, t) {
        "use strict";
        t("0a72");
      }, "825a": function(A2, e, t) {
        var n = t("861d");
        A2.exports = function(A3) {
          if (!n(A3))
            throw TypeError(String(A3) + " is not an object");
          return A3;
        };
      }, "83ab": function(A2, e, t) {
        var n = t("d039");
        A2.exports = !n(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      }, 8418: function(A2, e, t) {
        "use strict";
        var n = t("c04e"), r = t("9bf2"), o = t("5c6c");
        A2.exports = function(A3, e2, t2) {
          var c = n(e2);
          c in A3 ? r.f(A3, c, o(0, t2)) : A3[c] = t2;
        };
      }, "861d": function(A2, e) {
        A2.exports = function(A3) {
          return typeof A3 === "object" ? A3 !== null : typeof A3 === "function";
        };
      }, 8875: function(A2, e, t) {
        var n, r, o;
        (function(t2, c) {
          r = [], n = c, o = typeof n === "function" ? n.apply(e, r) : n, o === void 0 || (A2.exports = o);
        })(typeof self !== "undefined" && self, function() {
          function A3() {
            var e2 = Object.getOwnPropertyDescriptor(document, "currentScript");
            if (!e2 && "currentScript" in document && document.currentScript)
              return document.currentScript;
            if (e2 && e2.get !== A3 && document.currentScript)
              return document.currentScript;
            try {
              throw new Error();
            } catch (C) {
              var t2, n2, r2, o2 = /.*at [^(]*\((.*):(.+):(.+)\)$/gi, c = /@([^@]*):(\d+):(\d+)\s*$/gi, i = o2.exec(C.stack) || c.exec(C.stack), a = i && i[1] || false, g = i && i[2] || false, u = document.location.href.replace(document.location.hash, ""), s = document.getElementsByTagName("script");
              a === u && (t2 = document.documentElement.outerHTML, n2 = new RegExp("(?:[^\\n]+?\\n){0," + (g - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i"), r2 = t2.replace(n2, "$1").trim());
              for (var l = 0; l < s.length; l++) {
                if (s[l].readyState === "interactive")
                  return s[l];
                if (s[l].src === a)
                  return s[l];
                if (a === u && s[l].innerHTML && s[l].innerHTML.trim() === r2)
                  return s[l];
              }
              return null;
            }
          }
          return A3;
        });
      }, 8925: function(A2, e, t) {
        var n = t("c6cd"), r = Function.toString;
        typeof n.inspectSource != "function" && (n.inspectSource = function(A3) {
          return r.call(A3);
        }), A2.exports = n.inspectSource;
      }, "8bbf": function(e, t) {
        e.exports = A;
      }, "90e3": function(A2, e) {
        var t = 0, n = Math.random();
        A2.exports = function(A3) {
          return "Symbol(" + String(A3 === void 0 ? "" : A3) + ")_" + (++t + n).toString(36);
        };
      }, 9112: function(A2, e, t) {
        var n = t("83ab"), r = t("9bf2"), o = t("5c6c");
        A2.exports = n ? function(A3, e2, t2) {
          return r.f(A3, e2, o(1, t2));
        } : function(A3, e2, t2) {
          return A3[e2] = t2, A3;
        };
      }, "94ca": function(A2, e, t) {
        var n = t("d039"), r = /#|\.prototype\./, o = function(A3, e2) {
          var t2 = i[c(A3)];
          return t2 == g || t2 != a && (typeof e2 == "function" ? n(e2) : !!e2);
        }, c = o.normalize = function(A3) {
          return String(A3).replace(r, ".").toLowerCase();
        }, i = o.data = {}, a = o.NATIVE = "N", g = o.POLYFILL = "P";
        A2.exports = o;
      }, "964c": function(A2, e) {
        A2.exports = "data:image/png;base64,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";
      }, "9bf2": function(A2, e, t) {
        var n = t("83ab"), r = t("0cfb"), o = t("825a"), c = t("c04e"), i = Object.defineProperty;
        e.f = n ? i : function(A3, e2, t2) {
          if (o(A3), e2 = c(e2, true), o(t2), r)
            try {
              return i(A3, e2, t2);
            } catch (n2) {
            }
          if ("get" in t2 || "set" in t2)
            throw TypeError("Accessors not supported");
          return "value" in t2 && (A3[e2] = t2.value), A3;
        };
      }, "9cc3": function(A2, e) {
        A2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADyUlEQVRYR8VXX4hUVRj/fXcWfQpC1DAzBIseJLGwh8DKEF2SKNuohyWjHoTAJ5Od7rlz7+517uz5rhrbQ2AkRNk+CEUWgRGGBP0Fo8AVCQuxf6ixhdGT5u754szcO96ZnZm9cxX2wDzMme/7/X7nO9+fM4QFXrTA/OhLQKUytsEYsxXAFgC3A1hBhKsiOEuEn42RX0Xog337otN5D5ZLgFKVHYDzHABLnmd9DJijzOOH2409z1uhtb6Y7vcU4Hlj60TMgXZiIvyVnPq0CP4VwRIiLAHoTkA2NMEJxxYtKg2FYfif3SuXx+4olczvAL5njup2XQW47ugzRPI6gNsSwHMimBgYkBO1Wu1stzB4XjAsgucBDCY2MwAeZo6+dV1/ExF9bveZozp3RwEJ+XsJwFUArwEzE8w8nSf+1sZ1/ZCIxq7bl9aKzCyfV4BSwUMAvkgc/yGa3ay1/iEvcdbOdYOXiPBGuicij84rwHWDT4jwmHUSoeE4rh4pQp76KOVvB+jD5Lu9/1Vdr8B1gxeI8Hb9bohY66p3I+TXRQQWZzyL1TEHlAqOAdgG4FPmqB6FIksp/3ERNKshOdB9AJ5I8eYIcN3gASKcTAz2MEcTRcitj1LBeQCre/nPEeB5/ogI7bdOxmBdP92snSipgEd6CDjJHL3SUoZKBbY+NwH4mjnaWPT0/fo1+0AaNhHZG8e1sF+govZNAa4briYym5mrbxUFK+KXaxgVAe7kUy6Xb3GcxTscx/lK671TLTlws0h64SjlbwPIlvoF5mjlAggYPQTITgA/MUf3tAiYr3SI6Dutq+WikQrDcOmVK7M/EmEpIEeYa8PtZSjzgE8zR8uLClDK3wnQIesvgl1xHB3sJeCSiLzZSuaciePq+8UFNNv8NDCzNh3t2T7QHoEbmgdZodm3AREOah3tSn/vJOAjANsTgxHm6NWip7Z+lcroU8bI0QaGTBGZrVrrP7sKsJ2QyHkSkPWN+zJDcTyezvO+tHiedz9Q+sy+GRtYMhjHteNZkDkRSFuxUsFlALfWE4VoXOuqn5ddKbUMGHgZwG4Aixvk9GynHOoqwDopFXwD4MGE+BQRHRa59i4z/91JzMiIv6ZUokEiWPI1qU2v+ZIVUJ+GIngxjqN3UmfP8/eIUDYP/iDCKWNw2T7PAdhX773Jx/5Zya7fAPKZq5PdotcyC+xAiuPwl3bjRgt1hgB5Or2W3tchUwBNEs1OZhOuk09fw8j+q7FCjKH1RLgLwN0AltneDuCiiBwnohPM0Zd586UvAXlB+7FbcAH/A4UEhDCH3H8GAAAAAElFTkSuQmCC";
      }, a4d3: function(A2, e, t) {
        "use strict";
        var n = t("23e7"), r = t("da84"), o = t("d066"), c = t("c430"), i = t("83ab"), a = t("4930"), g = t("fdbf"), u = t("d039"), s = t("5135"), l = t("e8b5"), C = t("861d"), f = t("825a"), B = t("7b0b"), E = t("fc6a"), d = t("c04e"), w = t("5c6c"), I = t("7c73"), p = t("df75"), Q = t("241c"), v = t("057f"), m = t("7418"), b = t("06cf"), O = t("9bf2"), h = t("d1e7"), y = t("9112"), D = t("6eeb"), T = t("5692"), Y = t("f772"), L = t("d012"), S = t("90e3"), M = t("b622"), k = t("e538"), V = t("746f"), P = t("d44e"), K = t("69f3"), R = t("b727").forEach, J = Y("hidden"), x = "Symbol", N = "prototype", U = M("toPrimitive"), j = K.set, G = K.getterFor(x), F = Object[N], H = r.Symbol, z = o("JSON", "stringify"), Z = b.f, q = O.f, X = v.f, W = h.f, _ = T("symbols"), $ = T("op-symbols"), AA = T("string-to-symbol-registry"), eA = T("symbol-to-string-registry"), tA = T("wks"), nA = r.QObject, rA = !nA || !nA[N] || !nA[N].findChild, oA = i && u(function() {
          return I(q({}, "a", { get: function() {
            return q(this, "a", { value: 7 }).a;
          } })).a != 7;
        }) ? function(A3, e2, t2) {
          var n2 = Z(F, e2);
          n2 && delete F[e2], q(A3, e2, t2), n2 && A3 !== F && q(F, e2, n2);
        } : q, cA = function(A3, e2) {
          var t2 = _[A3] = I(H[N]);
          return j(t2, { type: x, tag: A3, description: e2 }), i || (t2.description = e2), t2;
        }, iA = g ? function(A3) {
          return typeof A3 == "symbol";
        } : function(A3) {
          return Object(A3) instanceof H;
        }, aA = function(A3, e2, t2) {
          A3 === F && aA($, e2, t2), f(A3);
          var n2 = d(e2, true);
          return f(t2), s(_, n2) ? (t2.enumerable ? (s(A3, J) && A3[J][n2] && (A3[J][n2] = false), t2 = I(t2, { enumerable: w(0, false) })) : (s(A3, J) || q(A3, J, w(1, {})), A3[J][n2] = true), oA(A3, n2, t2)) : q(A3, n2, t2);
        }, gA = function(A3, e2) {
          f(A3);
          var t2 = E(e2), n2 = p(t2).concat(fA(t2));
          return R(n2, function(e3) {
            i && !sA.call(t2, e3) || aA(A3, e3, t2[e3]);
          }), A3;
        }, uA = function(A3, e2) {
          return e2 === void 0 ? I(A3) : gA(I(A3), e2);
        }, sA = function(A3) {
          var e2 = d(A3, true), t2 = W.call(this, e2);
          return !(this === F && s(_, e2) && !s($, e2)) && (!(t2 || !s(this, e2) || !s(_, e2) || s(this, J) && this[J][e2]) || t2);
        }, lA = function(A3, e2) {
          var t2 = E(A3), n2 = d(e2, true);
          if (t2 !== F || !s(_, n2) || s($, n2)) {
            var r2 = Z(t2, n2);
            return !r2 || !s(_, n2) || s(t2, J) && t2[J][n2] || (r2.enumerable = true), r2;
          }
        }, CA = function(A3) {
          var e2 = X(E(A3)), t2 = [];
          return R(e2, function(A4) {
            s(_, A4) || s(L, A4) || t2.push(A4);
          }), t2;
        }, fA = function(A3) {
          var e2 = A3 === F, t2 = X(e2 ? $ : E(A3)), n2 = [];
          return R(t2, function(A4) {
            !s(_, A4) || e2 && !s(F, A4) || n2.push(_[A4]);
          }), n2;
        };
        if (a || (H = function() {
          if (this instanceof H)
            throw TypeError("Symbol is not a constructor");
          var A3 = arguments.length && arguments[0] !== void 0 ? String(arguments[0]) : void 0, e2 = S(A3), t2 = function(A4) {
            this === F && t2.call($, A4), s(this, J) && s(this[J], e2) && (this[J][e2] = false), oA(this, e2, w(1, A4));
          };
          return i && rA && oA(F, e2, { configurable: true, set: t2 }), cA(e2, A3);
        }, D(H[N], "toString", function() {
          return G(this).tag;
        }), D(H, "withoutSetter", function(A3) {
          return cA(S(A3), A3);
        }), h.f = sA, O.f = aA, b.f = lA, Q.f = v.f = CA, m.f = fA, k.f = function(A3) {
          return cA(M(A3), A3);
        }, i && (q(H[N], "description", { configurable: true, get: function() {
          return G(this).description;
        } }), c || D(F, "propertyIsEnumerable", sA, { unsafe: true }))), n({ global: true, wrap: true, forced: !a, sham: !a }, { Symbol: H }), R(p(tA), function(A3) {
          V(A3);
        }), n({ target: x, stat: true, forced: !a }, { for: function(A3) {
          var e2 = String(A3);
          if (s(AA, e2))
            return AA[e2];
          var t2 = H(e2);
          return AA[e2] = t2, eA[t2] = e2, t2;
        }, keyFor: function(A3) {
          if (!iA(A3))
            throw TypeError(A3 + " is not a symbol");
          if (s(eA, A3))
            return eA[A3];
        }, useSetter: function() {
          rA = true;
        }, useSimple: function() {
          rA = false;
        } }), n({ target: "Object", stat: true, forced: !a, sham: !i }, { create: uA, defineProperty: aA, defineProperties: gA, getOwnPropertyDescriptor: lA }), n({ target: "Object", stat: true, forced: !a }, { getOwnPropertyNames: CA, getOwnPropertySymbols: fA }), n({ target: "Object", stat: true, forced: u(function() {
          m.f(1);
        }) }, { getOwnPropertySymbols: function(A3) {
          return m.f(B(A3));
        } }), z) {
          var BA = !a || u(function() {
            var A3 = H();
            return z([A3]) != "[null]" || z({ a: A3 }) != "{}" || z(Object(A3)) != "{}";
          });
          n({ target: "JSON", stat: true, forced: BA }, { stringify: function(A3, e2, t2) {
            var n2, r2 = [A3], o2 = 1;
            while (arguments.length > o2)
              r2.push(arguments[o2++]);
            if (n2 = e2, (C(e2) || A3 !== void 0) && !iA(A3))
              return l(e2) || (e2 = function(A4, e3) {
                if (typeof n2 == "function" && (e3 = n2.call(this, A4, e3)), !iA(e3))
                  return e3;
              }), r2[1] = e2, z.apply(null, r2);
          } });
        }
        H[N][U] || y(H[N], U, H[N].valueOf), P(H, x), L[J] = true;
      }, a640: function(A2, e, t) {
        "use strict";
        var n = t("d039");
        A2.exports = function(A3, e2) {
          var t2 = [][A3];
          return !!t2 && n(function() {
            t2.call(null, e2 || function() {
              throw 1;
            }, 1);
          });
        };
      }, a691: function(A2, e) {
        var t = Math.ceil, n = Math.floor;
        A2.exports = function(A3) {
          return isNaN(A3 = +A3) ? 0 : (A3 > 0 ? n : t)(A3);
        };
      }, a71a: function(A2, e, t) {
      }, a9e3: function(A2, e, t) {
        "use strict";
        var n = t("83ab"), r = t("da84"), o = t("94ca"), c = t("6eeb"), i = t("5135"), a = t("c6b6"), g = t("7156"), u = t("c04e"), s = t("d039"), l = t("7c73"), C = t("241c").f, f = t("06cf").f, B = t("9bf2").f, E = t("58a8").trim, d = "Number", w = r[d], I = w.prototype, p = a(l(I)) == d, Q = function(A3) {
          var e2, t2, n2, r2, o2, c2, i2, a2, g2 = u(A3, false);
          if (typeof g2 == "string" && g2.length > 2) {
            if (g2 = E(g2), e2 = g2.charCodeAt(0), e2 === 43 || e2 === 45) {
              if (t2 = g2.charCodeAt(2), t2 === 88 || t2 === 120)
                return NaN;
            } else if (e2 === 48) {
              switch (g2.charCodeAt(1)) {
                case 66:
                case 98:
                  n2 = 2, r2 = 49;
                  break;
                case 79:
                case 111:
                  n2 = 8, r2 = 55;
                  break;
                default:
                  return +g2;
              }
              for (o2 = g2.slice(2), c2 = o2.length, i2 = 0; i2 < c2; i2++)
                if (a2 = o2.charCodeAt(i2), a2 < 48 || a2 > r2)
                  return NaN;
              return parseInt(o2, n2);
            }
          }
          return +g2;
        };
        if (o(d, !w(" 0o1") || !w("0b1") || w("+0x1"))) {
          for (var v, m = function(A3) {
            var e2 = arguments.length < 1 ? 0 : A3, t2 = this;
            return t2 instanceof m && (p ? s(function() {
              I.valueOf.call(t2);
            }) : a(t2) != d) ? g(new w(Q(e2)), t2, m) : Q(e2);
          }, b = n ? C(w) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","), O = 0; b.length > O; O++)
            i(w, v = b[O]) && !i(m, v) && B(m, v, f(w, v));
          m.prototype = I, I.constructor = m, c(r, d, m);
        }
      }, b0c0: function(A2, e, t) {
        var n = t("83ab"), r = t("9bf2").f, o = Function.prototype, c = o.toString, i = /^\s*function ([^ (]*)/, a = "name";
        n && !(a in o) && r(o, a, { configurable: true, get: function() {
          try {
            return c.call(this).match(i)[1];
          } catch (A3) {
            return "";
          }
        } });
      }, b258: function(A2, e, t) {
      }, b622: function(A2, e, t) {
        var n = t("da84"), r = t("5692"), o = t("5135"), c = t("90e3"), i = t("4930"), a = t("fdbf"), g = r("wks"), u = n.Symbol, s = a ? u : u && u.withoutSetter || c;
        A2.exports = function(A3) {
          return o(g, A3) && (i || typeof g[A3] == "string") || (i && o(u, A3) ? g[A3] = u[A3] : g[A3] = s("Symbol." + A3)), g[A3];
        };
      }, b64b: function(A2, e, t) {
        var n = t("23e7"), r = t("7b0b"), o = t("df75"), c = t("d039"), i = c(function() {
          o(1);
        });
        n({ target: "Object", stat: true, forced: i }, { keys: function(A3) {
          return o(r(A3));
        } });
      }, b727: function(A2, e, t) {
        var n = t("0366"), r = t("44ad"), o = t("7b0b"), c = t("50c4"), i = t("65f0"), a = [].push, g = function(A3) {
          var e2 = A3 == 1, t2 = A3 == 2, g2 = A3 == 3, u = A3 == 4, s = A3 == 6, l = A3 == 7, C = A3 == 5 || s;
          return function(f, B, E, d) {
            for (var w, I, p = o(f), Q = r(p), v = n(B, E, 3), m = c(Q.length), b = 0, O = d || i, h = e2 ? O(f, m) : t2 || l ? O(f, 0) : void 0; m > b; b++)
              if ((C || b in Q) && (w = Q[b], I = v(w, b, p), A3))
                if (e2)
                  h[b] = I;
                else if (I)
                  switch (A3) {
                    case 3:
                      return true;
                    case 5:
                      return w;
                    case 6:
                      return b;
                    case 2:
                      a.call(h, w);
                  }
                else
                  switch (A3) {
                    case 4:
                      return false;
                    case 7:
                      a.call(h, w);
                  }
            return s ? -1 : g2 || u ? u : h;
          };
        };
        A2.exports = { forEach: g(0), map: g(1), filter: g(2), some: g(3), every: g(4), find: g(5), findIndex: g(6), filterOut: g(7) };
      }, c04e: function(A2, e, t) {
        var n = t("861d");
        A2.exports = function(A3, e2) {
          if (!n(A3))
            return A3;
          var t2, r;
          if (e2 && typeof (t2 = A3.toString) == "function" && !n(r = t2.call(A3)))
            return r;
          if (typeof (t2 = A3.valueOf) == "function" && !n(r = t2.call(A3)))
            return r;
          if (!e2 && typeof (t2 = A3.toString) == "function" && !n(r = t2.call(A3)))
            return r;
          throw TypeError("Can't convert object to primitive value");
        };
      }, c430: function(A2, e) {
        A2.exports = false;
      }, c6b6: function(A2, e) {
        var t = {}.toString;
        A2.exports = function(A3) {
          return t.call(A3).slice(8, -1);
        };
      }, c6cd: function(A2, e, t) {
        var n = t("da84"), r = t("ce4e"), o = "__core-js_shared__", c = n[o] || r(o, {});
        A2.exports = c;
      }, c8ba: function(A2, e) {
        var t;
        t = function() {
          return this;
        }();
        try {
          t = t || new Function("return this")();
        } catch (n) {
          typeof window === "object" && (t = window);
        }
        A2.exports = t;
      }, ca84: function(A2, e, t) {
        var n = t("5135"), r = t("fc6a"), o = t("4d64").indexOf, c = t("d012");
        A2.exports = function(A3, e2) {
          var t2, i = r(A3), a = 0, g = [];
          for (t2 in i)
            !n(c, t2) && n(i, t2) && g.push(t2);
          while (e2.length > a)
            n(i, t2 = e2[a++]) && (~o(g, t2) || g.push(t2));
          return g;
        };
      }, cb29: function(A2, e, t) {
        var n = t("23e7"), r = t("81d5"), o = t("44d2");
        n({ target: "Array", proto: true }, { fill: r }), o("fill");
      }, cb51: function(A2, e, t) {
      }, cc12: function(A2, e, t) {
        var n = t("da84"), r = t("861d"), o = n.document, c = r(o) && r(o.createElement);
        A2.exports = function(A3) {
          return c ? o.createElement(A3) : {};
        };
      }, ce4e: function(A2, e, t) {
        var n = t("da84"), r = t("9112");
        A2.exports = function(A3, e2) {
          try {
            r(n, A3, e2);
          } catch (t2) {
            n[A3] = e2;
          }
          return e2;
        };
      }, d012: function(A2, e) {
        A2.exports = {};
      }, d039: function(A2, e) {
        A2.exports = function(A3) {
          try {
            return !!A3();
          } catch (e2) {
            return true;
          }
        };
      }, d066: function(A2, e, t) {
        var n = t("428f"), r = t("da84"), o = function(A3) {
          return typeof A3 == "function" ? A3 : void 0;
        };
        A2.exports = function(A3, e2) {
          return arguments.length < 2 ? o(n[A3]) || o(r[A3]) : n[A3] && n[A3][e2] || r[A3] && r[A3][e2];
        };
      }, d1e7: function(A2, e, t) {
        "use strict";
        var n = {}.propertyIsEnumerable, r = Object.getOwnPropertyDescriptor, o = r && !n.call({ 1: 2 }, 1);
        e.f = o ? function(A3) {
          var e2 = r(this, A3);
          return !!e2 && e2.enumerable;
        } : n;
      }, d2bb: function(A2, e, t) {
        var n = t("825a"), r = t("3bbe");
        A2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var A3, e2 = false, t2 = {};
          try {
            A3 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set, A3.call(t2, []), e2 = t2 instanceof Array;
          } catch (o) {
          }
          return function(t3, o) {
            return n(t3), r(o), e2 ? A3.call(t3, o) : t3.__proto__ = o, t3;
          };
        }() : void 0);
      }, d44e: function(A2, e, t) {
        var n = t("9bf2").f, r = t("5135"), o = t("b622"), c = o("toStringTag");
        A2.exports = function(A3, e2, t2) {
          A3 && !r(A3 = t2 ? A3 : A3.prototype, c) && n(A3, c, { configurable: true, value: e2 });
        };
      }, da84: function(A2, e, t) {
        (function(e2) {
          var t2 = function(A3) {
            return A3 && A3.Math == Math && A3;
          };
          A2.exports = t2(typeof globalThis == "object" && globalThis) || t2(typeof window == "object" && window) || t2(typeof self == "object" && self) || t2(typeof e2 == "object" && e2) || function() {
            return this;
          }() || Function("return this")();
        }).call(this, t("c8ba"));
      }, dbb4: function(A2, e, t) {
        var n = t("23e7"), r = t("83ab"), o = t("56ef"), c = t("fc6a"), i = t("06cf"), a = t("8418");
        n({ target: "Object", stat: true, sham: !r }, { getOwnPropertyDescriptors: function(A3) {
          var e2, t2, n2 = c(A3), r2 = i.f, g = o(n2), u = {}, s = 0;
          while (g.length > s)
            t2 = r2(n2, e2 = g[s++]), t2 !== void 0 && a(u, e2, t2);
          return u;
        } });
      }, df75: function(A2, e, t) {
        var n = t("ca84"), r = t("7839");
        A2.exports = Object.keys || function(A3) {
          return n(A3, r);
        };
      }, e1d6: function(A2, e) {
        A2.exports = "data:image/png;base64,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";
      }, e3b3: function(A2, e, t) {
      }, e439: function(A2, e, t) {
        var n = t("23e7"), r = t("d039"), o = t("fc6a"), c = t("06cf").f, i = t("83ab"), a = r(function() {
          c(1);
        }), g = !i || a;
        n({ target: "Object", stat: true, forced: g, sham: !i }, { getOwnPropertyDescriptor: function(A3, e2) {
          return c(o(A3), e2);
        } });
      }, e538: function(A2, e, t) {
        var n = t("b622");
        e.f = n;
      }, e893: function(A2, e, t) {
        var n = t("5135"), r = t("56ef"), o = t("06cf"), c = t("9bf2");
        A2.exports = function(A3, e2) {
          for (var t2 = r(e2), i = c.f, a = o.f, g = 0; g < t2.length; g++) {
            var u = t2[g];
            n(A3, u) || i(A3, u, a(e2, u));
          }
        };
      }, e8b5: function(A2, e, t) {
        var n = t("c6b6");
        A2.exports = Array.isArray || function(A3) {
          return n(A3) == "Array";
        };
      }, f772: function(A2, e, t) {
        var n = t("5692"), r = t("90e3"), o = n("keys");
        A2.exports = function(A3) {
          return o[A3] || (o[A3] = r(A3));
        };
      }, fb15: function(A2, e, t) {
        "use strict";
        if (t.r(e), t.d(e, "install", function() {
          return Se;
        }), typeof window !== "undefined") {
          var n = window.document.currentScript, r = t("8875");
          n = r(), "currentScript" in document || Object.defineProperty(document, "currentScript", { get: r });
          var o = n && n.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
          o && (t.p = o[1]);
        }
        t("b0c0");
        var c = t("8bbf"), i = t("e1d6"), a = t.n(i), g = t("964c"), u = t.n(g), s = t("492e"), l = t.n(s), C = t("28fa"), f = t.n(C), B = t("5078"), E = t.n(B), d = t("9cc3"), w = t.n(d), I = Object(c["withScopeId"])("data-v-292de9b8");
        Object(c["pushScopeId"])("data-v-292de9b8");
        var p = { id: "plugin-slider-verify_containe" }, Q = { id: "canvas_containe" }, v = Object(c["createVNode"])("span", null, "\u52A0\u8F7D\u4E2D...", -1), m = { id: "bg_canvas" }, b = { class: "slide-box" }, O = { class: "verticals" }, h = Object(c["createVNode"])("img", { src: a.a, alt: "" }, null, -1), y = Object(c["createVNode"])("img", { src: a.a, alt: "" }, null, -1), D = Object(c["createVNode"])("img", { src: a.a, alt: "" }, null, -1), T = { class: "arrow" }, Y = Object(c["createVNode"])("img", { src: u.a, alt: "" }, null, -1), L = Object(c["createVNode"])("img", { src: l.a, class: "circle", alt: "" }, null, -1), S = Object(c["createVNode"])("img", { src: f.a, alt: "" }, null, -1), M = Object(c["createVNode"])("span", { id: "placehold" }, "\u62D6\u52A8\u6ED1\u5757\u5B8C\u6210\u62FC\u56FE", -1), k = { key: 0, class: "operational" };
        Object(c["popScopeId"])();
        var V = I(function(A3, e2, t2, n2, r2, o2) {
          var i2 = Object(c["resolveComponent"])("loading"), a2 = Object(c["resolveComponent"])("popup");
          return Object(c["openBlock"])(), Object(c["createBlock"])("div", p, [Object(c["withDirectives"])(Object(c["createVNode"])("div", { id: "slider-verify", class: { "is-border": A3.isBorder } }, [Object(c["createVNode"])("div", { id: "verify_containe", class: { "is-opt": A3.isCloseBtn || A3.isReloadBtn } }, [Object(c["createVNode"])("div", Q, [A3.loading ? (Object(c["openBlock"])(), Object(c["createBlock"])("div", { key: 0, class: "loading", style: { width: "".concat(A3.width, "px"), height: "".concat(A3.height, "px") } }, [Object(c["createVNode"])(i2, { type: "circular", vertical: "" }, { default: I(function() {
            return [v];
          }), _: 1 })], 4)) : Object(c["createCommentVNode"])("", true), Object(c["withDirectives"])(Object(c["createVNode"])("canvas", m, null, 512), [[c["vShow"], !A3.loading]]), Object(c["withDirectives"])(Object(c["createVNode"])("canvas", { id: "block_canvas", onMousedown: e2[1] || (e2[1] = Object(c["withModifiers"])(function(e3) {
            return A3.drag(e3, "block_canvas", "circle");
          }, ["prevent"])), onTouchstart: e2[2] || (e2[2] = function(e3) {
            A3.terminal = "mobile", A3.drag(e3, "block_canvas", "circle");
          }) }, null, 544), [[c["vShow"], !A3.loading]])]), Object(c["createVNode"])("div", b, [Object(c["createVNode"])("div", { id: "circle", onMousedown: e2[3] || (e2[3] = Object(c["withModifiers"])(function(e3) {
            return A3.drag(e3, "circle", "block_canvas");
          }, ["prevent"])), onTouchstart: e2[4] || (e2[4] = function(e3) {
            A3.terminal = "mobile", A3.drag(e3, "circle", "block_canvas");
          }) }, [Object(c["withDirectives"])(Object(c["createVNode"])("div", O, [h, y, D], 512), [[c["vShow"], !A3.isTouch]]), Object(c["withDirectives"])(Object(c["createVNode"])("div", T, [Y, L, S], 512), [[c["vShow"], A3.isTouch]])], 32), M]), A3.isCloseBtn || A3.isReloadBtn ? (Object(c["openBlock"])(), Object(c["createBlock"])("div", k, [A3.isCloseBtn ? (Object(c["openBlock"])(), Object(c["createBlock"])("img", { key: 0, src: E.a, alt: "", onClick: e2[5] || (e2[5] = function() {
            return A3.close && A3.close.apply(A3, arguments);
          }) })) : Object(c["createCommentVNode"])("", true), A3.isReloadBtn ? (Object(c["openBlock"])(), Object(c["createBlock"])("img", { key: 1, src: w.a, alt: "", onClick: e2[6] || (e2[6] = function() {
            return A3.reload && A3.reload.apply(A3, arguments);
          }) })) : Object(c["createCommentVNode"])("", true)])) : Object(c["createCommentVNode"])("", true)], 2)], 2), [[c["vShow"], A3.isShowSelf]]), Object(c["createVNode"])(a2, { show: A3.popupShow, "onUpdate:show": e2[7] || (e2[7] = function(e3) {
            return A3.popupShow = e3;
          }), position: "bottom", overlay: false, teleport: A3.getContainer(), class: ["result-popup", { "popup-success": A3.verifyResult }] }, { default: I(function() {
            return [Object(c["createTextVNode"])(Object(c["toDisplayString"])(A3.verifyResult ? A3.sText : A3.eText), 1)];
          }), _: 1 }, 8, ["show", "teleport", "class"])]);
        });
        t("b64b"), t("a4d3"), t("4de4"), t("e439"), t("159b"), t("dbb4");
        function P(A3, e2, t2) {
          return e2 in A3 ? Object.defineProperty(A3, e2, { value: t2, enumerable: true, configurable: true, writable: true }) : A3[e2] = t2, A3;
        }
        function K(A3, e2) {
          var t2 = Object.keys(A3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(A3);
            e2 && (n2 = n2.filter(function(e3) {
              return Object.getOwnPropertyDescriptor(A3, e3).enumerable;
            })), t2.push.apply(t2, n2);
          }
          return t2;
        }
        function R(A3) {
          for (var e2 = 1; e2 < arguments.length; e2++) {
            var t2 = arguments[e2] != null ? arguments[e2] : {};
            e2 % 2 ? K(Object(t2), true).forEach(function(e3) {
              P(A3, e3, t2[e3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(A3, Object.getOwnPropertyDescriptors(t2)) : K(Object(t2)).forEach(function(e3) {
              Object.defineProperty(A3, e3, Object.getOwnPropertyDescriptor(t2, e3));
            });
          }
          return A3;
        }
        t("68ef"), t("cb51"), t("3743"), t("e3b3"), t("a71a"), t("4d75"), t("b258");
        function J() {
        }
        var x = Object.assign, N = typeof window !== "undefined", U = null, j = { type: Boolean, default: true };
        function G(A3, e2) {
          var t2 = e2.split("."), n2 = A3;
          return t2.forEach((A4) => {
            var e3;
            n2 = (e3 = n2[A4]) != null ? e3 : "";
          }), n2;
        }
        function F(A3) {
          return A3 !== void 0 && A3 !== null;
        }
        function H(A3) {
          return typeof A3 === "function";
        }
        function z(A3) {
          return A3 !== null && typeof A3 === "object";
        }
        function Z(A3) {
          return typeof A3 === "number" || /^\d+(\.\d+)?$/.test(A3);
        }
        var q = /-(\w)/g;
        function X(A3) {
          return A3.replace(q, (A4, e2) => e2.toUpperCase());
        }
        function W(A3) {
          return A3.install = (e2) => {
            var { name: t2 } = A3;
            e2.component(t2, A3), e2.component(X("-" + t2), A3);
          }, A3;
        }
        function _(A3) {
          var e2 = Object(c["getCurrentInstance"])();
          e2 && x(e2.proxy, A3);
        }
        function $() {
          var A3 = Object(c["reactive"])({ show: false }), e2 = (e3) => {
            A3.show = e3;
          }, t2 = (t3) => {
            x(A3, t3), Object(c["nextTick"])(() => e2(true));
          }, n2 = () => e2(false);
          return _({ open: t2, close: n2, toggle: e2 }), { open: t2, close: n2, state: A3, toggle: e2 };
        }
        function AA(A3) {
          var e2 = Object(c["createApp"])(A3), t2 = document.createElement("div");
          return document.body.appendChild(t2), { instance: e2.mount(t2), unmount() {
            e2.unmount(), document.body.removeChild(t2);
          } };
        }
        function eA(A3, e2) {
          return e2 ? typeof e2 === "string" ? " " + A3 + "--" + e2 : Array.isArray(e2) ? e2.reduce((e3, t2) => e3 + eA(A3, t2), "") : Object.keys(e2).reduce((t2, n2) => t2 + (e2[n2] ? eA(A3, n2) : ""), "") : "";
        }
        function tA(A3) {
          return function(e2, t2) {
            return e2 && typeof e2 !== "string" && (t2 = e2, e2 = ""), e2 = e2 ? A3 + "__" + e2 : A3, "" + e2 + eA(e2, t2);
          };
        }
        var { hasOwnProperty: nA } = Object.prototype;
        function rA(A3, e2, t2) {
          var n2 = e2[t2];
          F(n2) && (nA.call(A3, t2) && z(n2) ? A3[t2] = oA(Object(A3[t2]), e2[t2]) : A3[t2] = n2);
        }
        function oA(A3, e2) {
          return Object.keys(e2).forEach((t2) => {
            rA(A3, e2, t2);
          }), A3;
        }
        var cA = { name: "\u59D3\u540D", tel: "\u7535\u8BDD", save: "\u4FDD\u5B58", confirm: "\u786E\u8BA4", cancel: "\u53D6\u6D88", delete: "\u5220\u9664", complete: "\u5B8C\u6210", loading: "\u52A0\u8F7D\u4E2D...", telEmpty: "\u8BF7\u586B\u5199\u7535\u8BDD", nameEmpty: "\u8BF7\u586B\u5199\u59D3\u540D", nameInvalid: "\u8BF7\u8F93\u5165\u6B63\u786E\u7684\u59D3\u540D", confirmDelete: "\u786E\u5B9A\u8981\u5220\u9664\u5417", telInvalid: "\u8BF7\u8F93\u5165\u6B63\u786E\u7684\u624B\u673A\u53F7", vanCalendar: { end: "\u7ED3\u675F", start: "\u5F00\u59CB", title: "\u65E5\u671F\u9009\u62E9", confirm: "\u786E\u5B9A", startEnd: "\u5F00\u59CB/\u7ED3\u675F", weekdays: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"], monthTitle: (A3, e2) => A3 + "\u5E74" + e2 + "\u6708", rangePrompt: (A3) => "\u9009\u62E9\u5929\u6570\u4E0D\u80FD\u8D85\u8FC7 " + A3 + " \u5929" }, vanCascader: { select: "\u8BF7\u9009\u62E9" }, vanContactCard: { addText: "\u6DFB\u52A0\u8054\u7CFB\u4EBA" }, vanContactList: { addText: "\u65B0\u5EFA\u8054\u7CFB\u4EBA" }, vanPagination: { prev: "\u4E0A\u4E00\u9875", next: "\u4E0B\u4E00\u9875" }, vanPullRefresh: { pulling: "\u4E0B\u62C9\u5373\u53EF\u5237\u65B0...", loosing: "\u91CA\u653E\u5373\u53EF\u5237\u65B0..." }, vanSubmitBar: { label: "\u5408\u8BA1\uFF1A" }, vanCoupon: { unlimited: "\u65E0\u4F7F\u7528\u95E8\u69DB", discount: (A3) => A3 + "\u6298", condition: (A3) => "\u6EE1" + A3 + "\u5143\u53EF\u7528" }, vanCouponCell: { title: "\u4F18\u60E0\u5238", tips: "\u6682\u65E0\u53EF\u7528", count: (A3) => A3 + "\u5F20\u53EF\u7528" }, vanCouponList: { empty: "\u6682\u65E0\u4F18\u60E0\u5238", exchange: "\u5151\u6362", close: "\u4E0D\u4F7F\u7528\u4F18\u60E0\u5238", enable: "\u53EF\u7528", disabled: "\u4E0D\u53EF\u7528", placeholder: "\u8BF7\u8F93\u5165\u4F18\u60E0\u7801" }, vanAddressEdit: { area: "\u5730\u533A", postal: "\u90AE\u653F\u7F16\u7801", areaEmpty: "\u8BF7\u9009\u62E9\u5730\u533A", addressEmpty: "\u8BF7\u586B\u5199\u8BE6\u7EC6\u5730\u5740", postalEmpty: "\u90AE\u653F\u7F16\u7801\u683C\u5F0F\u4E0D\u6B63\u786E", defaultAddress: "\u8BBE\u4E3A\u9ED8\u8BA4\u6536\u8D27\u5730\u5740", telPlaceholder: "\u6536\u8D27\u4EBA\u624B\u673A\u53F7", namePlaceholder: "\u6536\u8D27\u4EBA\u59D3\u540D", areaPlaceholder: "\u9009\u62E9\u7701 / \u5E02 / \u533A" }, vanAddressEditDetail: { label: "\u8BE6\u7EC6\u5730\u5740", placeholder: "\u8857\u9053\u95E8\u724C\u3001\u697C\u5C42\u623F\u95F4\u53F7\u7B49\u4FE1\u606F" }, vanAddressList: { add: "\u65B0\u589E\u5730\u5740" } }, iA = Object(c["ref"])("zh-CN"), aA = Object(c["reactive"])({ "zh-CN": cA }), gA = { messages() {
          return aA[iA.value];
        }, use(A3, e2) {
          iA.value = A3, this.add({ [A3]: e2 });
        }, add(A3 = {}) {
          oA(aA, A3);
        } }, uA = gA;
        function sA(A3) {
          var e2 = X(A3) + ".";
          return function(A4, ...t2) {
            var n2 = uA.messages(), r2 = G(n2, e2 + A4) || G(n2, A4);
            return H(r2) ? r2(...t2) : r2;
          };
        }
        function lA(A3) {
          var e2 = "van-" + A3;
          return [e2, tA(e2), sA(e2)];
        }
        var CA = 0;
        function fA(A3) {
          A3 ? (CA || document.body.classList.add("van-toast--unclickable"), CA++) : CA && (CA--, CA || document.body.classList.remove("van-toast--unclickable"));
        }
        function BA(A3) {
          if (F(A3))
            return Z(A3) ? A3 + "px" : String(A3);
        }
        function EA(A3) {
          if (F(A3)) {
            var e2 = BA(A3);
            return { width: e2, height: e2 };
          }
        }
        function dA(A3) {
          var e2 = {};
          return A3 !== void 0 && (e2.zIndex = +A3), e2;
        }
        var [wA, IA] = lA("badge"), pA = Object(c["defineComponent"])({ name: wA, props: { dot: Boolean, max: [Number, String], color: String, offset: Array, content: [Number, String], showZero: j, tag: { type: String, default: "div" } }, setup(A3, { slots: e2 }) {
          var t2 = () => {
            if (e2.content)
              return true;
            var { content: t3, showZero: n3 } = A3;
            return F(t3) && t3 !== "" && (n3 || t3 !== 0);
          }, n2 = () => {
            var { dot: n3, max: r3, content: o2 } = A3;
            if (!n3 && t2())
              return e2.content ? e2.content() : F(r3) && Z(o2) && +o2 > r3 ? r3 + "+" : o2;
          }, r2 = () => {
            if (t2() || A3.dot) {
              var r3 = { background: A3.color };
              if (A3.offset) {
                var [o2, i2] = A3.offset;
                e2.default ? (r3.top = BA(i2), r3.right = "-" + BA(o2)) : (r3.marginTop = BA(i2), r3.marginLeft = BA(o2));
              }
              return Object(c["createVNode"])("div", { class: IA({ dot: A3.dot, fixed: !!e2.default }), style: r3 }, [n2()]);
            }
          };
          return () => {
            if (e2.default) {
              var { tag: t3 } = A3;
              return Object(c["createVNode"])(t3, { class: IA("wrapper") }, { default: () => [e2.default(), r2()] });
            }
            return r2();
          };
        } }), QA = W(pA), [vA, mA] = lA("icon");
        function bA(A3) {
          return !!A3 && A3.includes("/");
        }
        var OA = Object(c["defineComponent"])({ name: vA, props: { dot: Boolean, name: String, size: [Number, String], badge: [Number, String], color: String, tag: { type: String, default: "i" }, classPrefix: { type: String, default: mA() } }, setup(A3, { slots: e2 }) {
          return () => {
            var { tag: t2, dot: n2, name: r2, size: o2, badge: i2, color: a2, classPrefix: g2 } = A3, u2 = bA(r2);
            return Object(c["createVNode"])(QA, { dot: n2, tag: t2, content: i2, class: [g2, u2 ? "" : g2 + "-" + r2], style: { color: a2, fontSize: BA(o2) } }, { default: () => [e2.default == null ? void 0 : e2.default(), u2 && Object(c["createVNode"])("img", { class: mA("image"), src: r2 }, null)] });
          };
        } }), hA = W(OA), yA = { show: Boolean, zIndex: [Number, String], overlay: j, duration: [Number, String], teleport: [String, Object], lockScroll: j, lazyRender: j, overlayStyle: Object, overlayClass: U, transitionAppear: Boolean, closeOnClickOverlay: j };
        Object.keys(yA);
        function DA(A3) {
          var e2;
          Object(c["onMounted"])(() => {
            A3(), Object(c["nextTick"])(() => {
              e2 = true;
            });
          }), Object(c["onActivated"])(() => {
            e2 && A3();
          });
        }
        var TA = t("22d1"), YA = false;
        if (TA["a"])
          try {
            var LA = {};
            Object.defineProperty(LA, "passive", { get() {
              YA = true;
            } }), window.addEventListener("test-passive", null, LA);
          } catch (ke) {
          }
        function SA(A3, e2, t2 = {}) {
          if (TA["a"]) {
            var n2, { target: r2 = window, passive: o2 = false, capture: i2 = false } = t2, a2 = () => {
              var t3 = Object(c["unref"])(r2);
              t3 && !n2 && (t3.addEventListener(A3, e2, YA ? { capture: i2, passive: o2 } : i2), n2 = true);
            }, g2 = () => {
              var t3 = Object(c["unref"])(r2);
              t3 && n2 && (t3.removeEventListener(A3, e2, i2), n2 = false);
            };
            Object(c["onUnmounted"])(g2), Object(c["onDeactivated"])(g2), DA(a2);
          }
        }
        var MA = /scroll|auto/i, kA = TA["a"] ? window : void 0;
        function VA(A3) {
          var e2 = 1;
          return A3.tagName !== "HTML" && A3.tagName !== "BODY" && A3.nodeType === e2;
        }
        function PA(A3, e2 = kA) {
          var t2 = A3;
          while (t2 && t2 !== e2 && VA(t2)) {
            var { overflowY: n2 } = window.getComputedStyle(t2);
            if (MA.test(n2))
              return t2;
            t2 = t2.parentNode;
          }
          return e2;
        }
        var KA = 10;
        function RA(A3, e2) {
          return A3 > e2 && A3 > KA ? "horizontal" : e2 > A3 && e2 > KA ? "vertical" : "";
        }
        function JA() {
          var A3 = Object(c["ref"])(0), e2 = Object(c["ref"])(0), t2 = Object(c["ref"])(0), n2 = Object(c["ref"])(0), r2 = Object(c["ref"])(0), o2 = Object(c["ref"])(0), i2 = Object(c["ref"])(""), a2 = () => i2.value === "vertical", g2 = () => i2.value === "horizontal", u2 = () => {
            t2.value = 0, n2.value = 0, r2.value = 0, o2.value = 0, i2.value = "";
          }, s2 = (t3) => {
            u2(), A3.value = t3.touches[0].clientX, e2.value = t3.touches[0].clientY;
          }, l2 = (c2) => {
            var a3 = c2.touches[0];
            t2.value = a3.clientX < 0 ? 0 : a3.clientX - A3.value, n2.value = a3.clientY - e2.value, r2.value = Math.abs(t2.value), o2.value = Math.abs(n2.value), i2.value || (i2.value = RA(r2.value, o2.value));
          };
          return { move: l2, start: s2, reset: u2, startX: A3, startY: e2, deltaX: t2, deltaY: n2, offsetX: r2, offsetY: o2, direction: i2, isVertical: a2, isHorizontal: g2 };
        }
        function xA(A3) {
          A3.stopPropagation();
        }
        function NA(A3, e2) {
          (typeof A3.cancelable !== "boolean" || A3.cancelable) && A3.preventDefault(), e2 && xA(A3);
        }
        var UA = 0, jA = "van-overflow-hidden";
        function GA(A3, e2) {
          var t2 = JA(), n2 = (e3) => {
            t2.move(e3);
            var n3 = t2.deltaY.value > 0 ? "10" : "01", r3 = PA(e3.target, A3.value), { scrollHeight: o3, offsetHeight: c2, scrollTop: i3 } = r3, a3 = "11";
            i3 === 0 ? a3 = c2 >= o3 ? "00" : "01" : i3 + c2 >= o3 && (a3 = "10"), a3 === "11" || !t2.isVertical() || parseInt(a3, 2) & parseInt(n3, 2) || NA(e3, true);
          }, r2 = () => {
            document.addEventListener("touchstart", t2.start), document.addEventListener("touchmove", n2, !!YA && { passive: false }), UA || document.body.classList.add(jA), UA++;
          }, o2 = () => {
            UA && (document.removeEventListener("touchstart", t2.start), document.removeEventListener("touchmove", n2), UA--, UA || document.body.classList.remove(jA));
          }, i2 = () => {
            e2() && r2();
          }, a2 = () => {
            e2() && o2();
          };
          DA(i2), Object(c["onDeactivated"])(a2), Object(c["onBeforeUnmount"])(a2), Object(c["watch"])(e2, (A4) => {
            A4 ? r2() : o2();
          });
        }
        function FA(A3) {
          var e2 = Object(c["ref"])(false);
          return Object(c["watch"])(A3, (A4) => {
            A4 && (e2.value = A4);
          }, { immediate: true }), (A4) => () => e2.value ? A4() : null;
        }
        var HA = Symbol();
        var [zA, ZA] = lA("overlay"), qA = Object(c["defineComponent"])({ name: zA, props: { show: Boolean, zIndex: [Number, String], duration: [Number, String], className: U, lockScroll: j, customStyle: Object }, setup(A3, { slots: e2 }) {
          var t2 = FA(() => A3.show), n2 = (A4) => {
            NA(A4, true);
          }, r2 = t2(() => {
            var t3 = x(dA(A3.zIndex), A3.customStyle);
            return F(A3.duration) && (t3.animationDuration = A3.duration + "s"), Object(c["withDirectives"])(Object(c["createVNode"])("div", { style: t3, class: [ZA(), A3.className], onTouchmove: A3.lockScroll ? n2 : J }, [e2.default == null ? void 0 : e2.default()]), [[c["vShow"], A3.show]]);
          });
          return () => Object(c["createVNode"])(c["Transition"], { name: "van-fade" }, { default: () => [r2()] });
        } }), XA = W(qA), [WA, _A] = lA("popup"), $A = 2e3, Ae = Object(c["defineComponent"])({ name: WA, inheritAttrs: false, props: x({}, yA, { round: Boolean, closeable: Boolean, transition: String, closeOnPopstate: Boolean, safeAreaInsetBottom: Boolean, position: { type: String, default: "center" }, closeIcon: { type: String, default: "cross" }, closeIconPosition: { type: String, default: "top-right" } }), emits: ["open", "close", "click", "opened", "closed", "update:show", "click-overlay", "click-close-icon"], setup(A3, { emit: e2, attrs: t2, slots: n2 }) {
          var r2, o2, i2 = Object(c["ref"])(), a2 = Object(c["ref"])(), g2 = FA(() => A3.show || !A3.lazyRender), u2 = Object(c["computed"])(() => {
            var e3 = { zIndex: i2.value };
            if (F(A3.duration)) {
              var t3 = A3.position === "center" ? "animationDuration" : "transitionDuration";
              e3[t3] = A3.duration + "s";
            }
            return e3;
          }), s2 = () => {
            r2 || (A3.zIndex !== void 0 && ($A = +A3.zIndex), r2 = true, i2.value = ++$A);
          }, l2 = () => {
            r2 && (r2 = false, e2("update:show", false));
          }, C2 = (t3) => {
            e2("click-overlay", t3), A3.closeOnClickOverlay && l2();
          }, f2 = () => {
            if (A3.overlay)
              return Object(c["createVNode"])(XA, { show: A3.show, class: A3.overlayClass, zIndex: i2.value, duration: A3.duration, customStyle: A3.overlayStyle, onClick: C2 }, null);
          }, B2 = (A4) => {
            e2("click-close-icon", A4), l2();
          }, E2 = () => {
            if (A3.closeable)
              return Object(c["createVNode"])(hA, { role: "button", tabindex: 0, name: A3.closeIcon, class: _A("close-icon", A3.closeIconPosition), onClick: B2 }, null);
          }, d2 = (A4) => e2("click", A4), w2 = () => e2("opened"), I2 = () => e2("closed"), p2 = g2(() => {
            var { round: e3, position: r3, safeAreaInsetBottom: o3 } = A3;
            return Object(c["withDirectives"])(Object(c["createVNode"])("div", Object(c["mergeProps"])({ ref: a2, style: u2.value, class: _A({ round: e3, [r3]: r3, "safe-area-inset-bottom": o3 }), onClick: d2 }, t2), [n2.default == null ? void 0 : n2.default(), E2()]), [[c["vShow"], A3.show]]);
          }), Q2 = () => {
            var { position: e3, transition: t3, transitionAppear: n3 } = A3, r3 = e3 === "center" ? "van-fade" : "van-popup-slide-" + e3;
            return Object(c["createVNode"])(c["Transition"], { name: t3 || r3, appear: n3, onAfterEnter: w2, onAfterLeave: I2 }, { default: () => [p2()] });
          };
          return Object(c["watch"])(() => A3.show, (A4) => {
            A4 ? (s2(), e2("open")) : (l2(), e2("close"));
          }), _({ popupRef: a2 }), GA(a2, () => A3.show && A3.lockScroll), SA("popstate", () => {
            A3.closeOnPopstate && (l2(), o2 = false);
          }), Object(c["onMounted"])(() => {
            A3.show && s2();
          }), Object(c["onActivated"])(() => {
            o2 && (e2("update:show", true), o2 = false);
          }), Object(c["onDeactivated"])(() => {
            A3.show && (l2(), o2 = true);
          }), Object(c["provide"])(HA, () => A3.show), () => A3.teleport ? Object(c["createVNode"])(c["Teleport"], { to: A3.teleport }, { default: () => [f2(), Q2()] }) : Object(c["createVNode"])(c["Fragment"], null, [f2(), Q2()]);
        } }), ee = W(Ae), te = ee, [ne, re] = lA("loading"), oe = Array(12).fill(Object(c["createVNode"])("i", null, null)), ce = Object(c["createVNode"])("svg", { class: re("circular"), viewBox: "25 25 50 50" }, [Object(c["createVNode"])("circle", { cx: "50", cy: "50", r: "20", fill: "none" }, null)]), ie = Object(c["defineComponent"])({ name: ne, props: { size: [Number, String], color: String, vertical: Boolean, textSize: [Number, String], textColor: String, type: { type: String, default: "circular" } }, setup(A3, { slots: e2 }) {
          var t2 = Object(c["computed"])(() => x({ color: A3.color }, EA(A3.size))), n2 = () => {
            var t3;
            if (e2.default)
              return Object(c["createVNode"])("span", { class: re("text"), style: { fontSize: BA(A3.textSize), color: (t3 = A3.textColor) != null ? t3 : A3.color } }, [e2.default()]);
          };
          return () => {
            var { type: e3, vertical: r2 } = A3;
            return Object(c["createVNode"])("div", { class: re([e3, { vertical: r2 }]) }, [Object(c["createVNode"])("span", { class: re("spinner", e3), style: t2.value }, [e3 === "spinner" ? oe : ce]), n2()]);
          };
        } }), ae = W(ie), ge = ae, [ue, se] = lA("toast"), le = Object(c["defineComponent"])({ name: ue, props: { icon: String, show: Boolean, overlay: Boolean, message: [Number, String], iconSize: [Number, String], className: U, iconPrefix: String, loadingType: String, forbidClick: Boolean, overlayClass: U, overlayStyle: Object, closeOnClick: Boolean, closeOnClickOverlay: Boolean, type: { type: String, default: "text" }, duration: { type: Number, default: 2e3 }, position: { type: String, default: "middle" }, transition: { type: String, default: "van-fade" } }, emits: ["update:show"], setup(A3, { emit: e2 }) {
          var t2, n2 = false, r2 = () => {
            var e3 = A3.show && A3.forbidClick;
            n2 !== e3 && (n2 = e3, fA(n2));
          }, o2 = (A4) => e2("update:show", A4), i2 = () => {
            A3.closeOnClick && o2(false);
          }, a2 = () => {
            clearTimeout(t2);
          }, g2 = () => {
            var { icon: e3, type: t3, iconSize: n3, iconPrefix: r3, loadingType: o3 } = A3, i3 = e3 || t3 === "success" || t3 === "fail";
            return i3 ? Object(c["createVNode"])(hA, { name: e3 || t3, size: n3, class: se("icon"), classPrefix: r3 }, null) : t3 === "loading" ? Object(c["createVNode"])(ae, { class: se("loading"), size: n3, type: o3 }, null) : void 0;
          }, u2 = () => {
            var { type: e3, message: t3 } = A3;
            if (F(t3) && t3 !== "")
              return e3 === "html" ? Object(c["createVNode"])("div", { class: se("text"), innerHTML: String(t3) }, null) : Object(c["createVNode"])("div", { class: se("text") }, [t3]);
          };
          return Object(c["watch"])(() => [A3.show, A3.forbidClick], r2), Object(c["watch"])(() => [A3.show, A3.duration], () => {
            a2(), A3.show && A3.duration > 0 && (t2 = setTimeout(() => {
              o2(false);
            }, A3.duration));
          }), Object(c["onMounted"])(r2), Object(c["onUnmounted"])(r2), () => Object(c["createVNode"])(ee, Object(c["mergeProps"])({ show: A3.show, class: [se([A3.position, { [A3.type]: !A3.icon }]), A3.className], overlay: A3.overlay, lockScroll: false, transition: A3.transition, overlayClass: A3.overlayClass, overlayStyle: A3.overlayStyle, closeOnClickOverlay: A3.closeOnClickOverlay, onClick: i2, onClosed: a2 }, { "onUpdate:show": o2 }), { default: () => [g2(), u2()] });
        } }), Ce = { icon: "", type: "text", message: "", className: "", overlay: false, onClose: void 0, onOpened: void 0, duration: 2e3, teleport: "body", iconSize: void 0, iconPrefix: void 0, position: "middle", transition: "van-fade", forbidClick: false, loadingType: void 0, overlayClass: "", overlayStyle: void 0, closeOnClick: false, closeOnClickOverlay: false }, fe = [], Be = false, Ee = x({}, Ce), de = {};
        function we(A3) {
          return z(A3) ? A3 : { message: A3 };
        }
        function Ie() {
          var { instance: A3, unmount: e2 } = AA({ setup() {
            var t2 = Object(c["ref"])(""), { open: n2, state: r2, close: o2, toggle: i2 } = $(), a2 = () => {
              Be && (fe = fe.filter((e3) => e3 !== A3), e2());
            }, g2 = () => {
              var A4 = { onClosed: a2, "onUpdate:show": i2 };
              return t2.value && (A4.message = t2.value), Object(c["createVNode"])(le, Object(c["mergeProps"])(r2, A4), null);
            };
            return Object(c["getCurrentInstance"])().render = g2, { open: n2, clear: o2, message: t2 };
          } });
          return A3;
        }
        function pe() {
          if (!fe.length || Be) {
            var A3 = Ie();
            fe.push(A3);
          }
          return fe[fe.length - 1];
        }
        function Qe(A3 = {}) {
          if (!N)
            return {};
          var e2 = pe(), t2 = we(A3);
          return e2.open(x({}, Ee, de[t2.type || Ee.type], t2)), e2;
        }
        var ve = (A3) => (e2) => Qe(x({ type: A3 }, we(e2)));
        function me(A3, e2) {
          typeof A3 === "string" ? de[A3] = e2 : x(Ee, A3);
        }
        Qe.loading = ve("loading"), Qe.success = ve("success"), Qe.fail = ve("fail"), Qe.clear = (A3) => {
          fe.length && (A3 ? (fe.forEach((A4) => {
            A4.clear();
          }), fe = []) : Be ? fe.shift().clear() : fe[0].clear());
        }, Qe.setDefaultOptions = me, Qe.resetDefaultOptions = (A3) => {
          typeof A3 === "string" ? de[A3] = null : (Ee = x({}, Ce), de = {});
        }, Qe.allowMultiple = (A3 = true) => {
          Be = A3;
        }, Qe.install = (A3) => {
          A3.use(W(le)), A3.config.globalProperties.$toast = Qe;
        };
        var be = Qe, Oe = (t("a9e3"), t("cb29"), 42), he = 9, ye = Math.PI, De = Oe + 2 * he + 3, Te = 70, Ye = Object(c["defineComponent"])({ name: "SliderVerify", props: { isShowSelf: { type: Boolean, default: false }, width: { type: Number, default: 300 }, height: { type: Number, default: 180 }, isBorder: { type: Boolean, default: true }, imgUrl: { type: String, default: "" }, sText: { type: String, default: "\u9A8C\u8BC1\u901A\u8FC7" }, eText: { type: String, default: "\u8BF7\u6B63\u786E\u62FC\u5408\u56FE\u50CF" }, isCloseBtn: { type: Boolean, default: true }, isReloadBtn: { type: Boolean, default: true }, isParentNode: { type: Boolean, default: false } }, components: { Popup: te, Loading: ge }, emits: ["update:isShowSelf", "hide", "show", "fail", "success", "close", "reload"], setup: function(A3, e2) {
          var t2 = Object(c["reactive"])({ popupShow: false, verifyResult: false, terminal: "pc", blkTilesW: 0, bgWidth: 0, isTouch: false, bgRandom: 0, loading: false, isLoad: false }), n2 = function() {
            g2(), e2.emit("reload");
          }, r2 = function() {
            e2.emit("update:isShowSelf", false), e2.emit("close");
          }, o2 = function() {
            return document.getElementById("canvas_containe");
          }, i2 = function(A4, n3, r3) {
            t2.isTouch = true;
            var o3 = document.querySelector("#".concat(n3)), c2 = document.querySelector("#".concat(r3)), i3 = document.querySelector("#placehold"), a3 = t2.terminal, u3 = 0, s2 = function(e3) {
              if (u3 = a3 === "pc" ? e3.x - A4.x : e3.changedTouches[0].clientX - A4.changedTouches[0].clientX, u3 < 8 && (i3.style.opacity = "1"), u3 >= t2.bgWidth - De || u3 <= -2)
                return false;
              o3.style.left = u3 + "px", c2.style.left = u3 + "px", i3.style.opacity = "0";
            }, l2 = function A5() {
              t2.isTouch = false, document.removeEventListener("mousemove", s2), document.removeEventListener("mouseup", A5), document.removeEventListener("touchmove", s2), document.removeEventListener("touchend", A5);
              var n4 = t2.blkTilesW + 5, r4 = t2.blkTilesW - 5;
              u3 >= r4 && u3 <= n4 ? (t2.verifyResult = true, e2.emit("success")) : (t2.verifyResult = false, e2.emit("fail")), t2.popupShow = true, setTimeout(function() {
                t2.popupShow = false;
              }, 500), o3.style.left = "0", c2.style.left = "0", g2();
            };
            a3 === "pc" ? (document.addEventListener("mousemove", s2), document.addEventListener("mouseup", l2)) : (document.addEventListener("touchmove", s2), document.addEventListener("touchend", l2));
          }, a2 = function(A4, e3, t3) {
            var n3 = e3.x, r3 = e3.y;
            A4.beginPath(), A4.moveTo(n3, r3), A4.arc(n3 + Oe / 2, r3 - he + 2, he, 0.72 * ye, 2.26 * ye), A4.lineTo(n3 + Oe, r3), A4.arc(n3 + Oe + he - 2, r3 + Oe / 2, he, 1.21 * ye, 2.78 * ye), A4.lineTo(n3 + Oe, r3 + Oe), A4.lineTo(n3, r3 + Oe), A4.arc(n3 + he - 2, r3 + Oe / 2, he + 0.4, 2.76 * ye, 1.24 * ye, true), A4.lineTo(n3, r3), A4.lineWidth = 1, A4.fillStyle = "rgba(255, 255, 255, 0.7)", A4.strokeStyle = "rgba(255, 255, 255, 0.7)", A4.stroke(), A4.globalCompositeOperation = "destination-over", t3 === "fill" ? A4.fill() : A4.clip();
          }, g2 = function() {
            t2.loading = true;
            var e3 = document.getElementById("bg_canvas"), n3 = e3.getContext("2d"), r3 = document.getElementById("block_canvas"), o3 = r3.getContext("2d"), c2 = document.getElementById("placehold");
            c2.style.opacity = "1";
            var i3 = function(A4, e4) {
              return Math.floor(Math.random() * (e4 - A4) + A4);
            }, g3 = i3(3, 0), u3 = new Image();
            u3.crossOrigin = "Anonymous", u3.src = A3.imgUrl ? A3.imgUrl : "https://portal.fuyunfeng.top/files/images/SliderVerify-".concat(g3, ".jpg"), u3.onerror = function() {
              be({ message: "\u56FE\u7247\u52A0\u8F7D\u5931\u8D25", position: "top" }), u3.src = "https://portal.fuyunfeng.top/files/images/SliderVerify-error.png";
            };
            var s2 = A3.width;
            if (A3.isParentNode) {
              var l2, C2 = document.getElementById("plugin-slider-verify_containe"), f2 = (l2 = C2.parentElement) === null || l2 === void 0 ? void 0 : l2.getBoundingClientRect().width;
              f2 && (s2 = f2 - 20), A3.isBorder && (s2 -= 2);
            }
            var B2 = A3.height;
            t2.bgWidth = s2;
            var E2 = i3(De + 10, s2 - (De + 10));
            t2.blkTilesW = E2, e3.width = s2, e3.height = B2, r3.width = s2, r3.height = B2, u3.onload = function() {
              t2.loading = false, a2(n3, { x: E2, y: Te, r: he }, "fill"), a2(o3, { x: E2, y: Te, r: he }, "clip"), n3 === null || n3 === void 0 || n3.drawImage(u3, 0, 0, s2, B2), o3 === null || o3 === void 0 || o3.drawImage(u3, 0, 0, s2, B2);
              var A4 = Te - 2 * he - 1, e4 = o3 === null || o3 === void 0 ? void 0 : o3.getImageData(E2 - 3, A4, De, De);
              r3.width = De, e4 && (o3 === null || o3 === void 0 || o3.putImageData(e4, 0, A4)), t2.isLoad = true;
            };
          };
          Object(c["watch"])(function() {
            return A3.isShowSelf;
          }, function(A4) {
            if (A4)
              return e2.emit("show");
            e2.emit("hide");
          });
          var u2 = Object(c["computed"])(function() {
            var e3 = A3.width, t3 = A3.height, n3 = A3.isBorder, r3 = A3.imgUrl, o3 = A3.isParentNode;
            return { width: e3, height: t3, isBorder: n3, imgUrl: r3, isParentNode: o3 };
          });
          return Object(c["watch"])(u2, function() {
            g2();
          }), Object(c["onMounted"])(function() {
            console.log("SliderVerify init"), g2();
          }), R(R({ context: e2 }, Object(c["toRefs"])(t2)), {}, { drag: i2, close: r2, reload: n2, getContainer: o2 });
        } });
        t("81da");
        Ye.render = V, Ye.__scopeId = "data-v-292de9b8";
        var Le = Ye, Se = function(A3) {
          A3.component(Le.name, Le);
        }, Me = { install: Se };
        e["default"] = Me;
      }, fc6a: function(A2, e, t) {
        var n = t("44ad"), r = t("1d80");
        A2.exports = function(A3) {
          return n(r(A3));
        };
      }, fdbc: function(A2, e) {
        A2.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
      }, fdbf: function(A2, e, t) {
        var n = t("4930");
        A2.exports = n && !Symbol.sham && typeof Symbol.iterator == "symbol";
      } });
    });
  }
});

// dep:slider-verify-v3
var slider_verify_v3_default = require_SliderVerify_umd_min();
export {
  slider_verify_v3_default as default
};
//# sourceMappingURL=slider-verify-v3.js.map
